Core-1
Что такое ООП
ООП - методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.

Согласно парадигме ООП программа состоит из объектов, обменивающихся сообщениями. Объекты могут обладать состоянием, единственный способ изменить состояние объекта - передать ему сообщение, в ответ на которое, объект может изменить собственное состояние.

Класс — это описание еще не созданного объекта, как бы общий шаблон, состоящий из полей, методов и конструктора, а объект – экземпляр класса, созданный на основе этого описания.

Какие преимущества у ООП
Легко читается - не нужно выискивать в коде функции и выяснять, за что они отвечают
Быстро пишется - можно быстро создать сущности, с которыми должна работать программа.
Простота реализации большого функционала - т.к. на написание кода уходит меньше времени, можно гораздо быстрее создать приложение с множеством возможностей
Меньше повторений кода - не нужно писать однотипные функции для разных сущностей

Какие недостатки у ООП
Снижает производительность - многие вещи технически реализованы иначе, поэтому они используют больше ресурсов.
Сложно начать - парадигма ООП сложнее функционального программирования, поэтому на старт уходит больше времени

Назовите основные принципы ООП
Инкапсуляция Наследование Полиморфизм

Что такое инкапсуляция? (С примером)
Свойство системы, которое объединяет данные и методы, манипулирующие этими данными, а также защищает и то, и другое от внешнего вмешательства или неправильного использования. Инкапсуляция - это объединение данных и методов работы с этими данными в одной упаковке («капсуле»). Чтобы малейшее изменение в классе не влекло за собой изменение внешнего поведения класса.
Объединение поведения и состояния этого класса, таким образом что бы состояние менялось только через методы.

Что такое наследование? (С примером)
Свойство системы, которое позволяет описать новый класс на основе уже существующего с частично или полностью заимствованной функциональностью.

Что такое полиморфизм? (С примером)
Способность работать с группой объектов как с одним.
Полиморфизм – предоставляет возможность единообразно обрабатывать объекты с различной реализацией при условии наличия у них общего интерфейса или класса.
Есть три вида полиморфизма:
-ad hoc полиморфизм, основан на различении типов. Для различных типов аргументов используется разный код метода, пример статического - перегрузка метода. Пример динамического - переопределение метода.
-параметрический полиморфизм - ситуация, когда один и тот же метод работает с аргументами различных типов одинаково, не зависимо от их точного типа. Пример — функция, работающая с объектом некоторого класса C, может без изменений работать с объектом порождённого от C класса (этот вид полиморфизма часто называют полиморфизм включения).
-subtype полиморфизм - самый популярный - возможность объектов с одинаковой
 
спецификацией(интерфейс\класс\abstract класс) иметь различную реализацию.

Пример:
Перегрузка методов, интерфейсы.

Что такое ассоциация
Есть два типа связи между объектами: ассоциация, которая делится на композицию и агрегацию, и наследование. Ассоциация - обозначает связь между обьектами. Например, игрок играет в определенной команде.

Ассоциация означает, что объекты двух классов могут ссылаться один на другой, иметь некоторую связь между друг другом. Например Менеджер может выписать Счет. Соответственно возникает ассоциация между Менеджером и Счетом. Еще пример — Преподаватель и Студент — т.е. какой-то Студент учится у какого-то Преподавателя. Ассоциация и есть описание связи между двумя объектами. Студент учится у Преподавателя.
Идея достаточно простая — два объекта могут быть связаны между собой и это надо как-то описать. http://java-course.ru/begin/relations/

Что такое композиция
Композиция — еще более «жесткое отношение, когда объект не только является частью другого объекта, но и вообще не может принадлежат еще кому-то. Например Машина и Двигатель. Хотя двигатель может быть и без машины, но он вряд ли сможет быть в двух или трех машинах одновременно. В отличии от студента, который может входить и в другие группы тоже.

Например, в класс автомобиля содержит объект класса электрического двигателя:
public class ElectricEngine{ }

public class Car { ElectricEngine engine; public Car()
{
engine = new ElectricEngine();
}
}
При этом класс автомобиля полностью управляет жизненным циклом объекта двигателя. При уничтожении объекта автомобиля в области памяти вместе с ним будет уничтожен и объект двигателя. И в этом плане объект автомобиля является главным, а объект двигателя - зависимой.

Что такое агрегация
Агрегация определяет отношение HAS A, но связь слабее чем в композиции, т.к. обьекты равноправны.

Расскажите про раннее и позднее связывание.
Связывание есть наличие связи между вызываемым методом программы и написанным кодом.

Ранее свзяывание
Если метод известен компилятору, то происходит ранее связывание на этапе компиляции (early binding), также называют статическим связыванием.

Позднее связывание (late binding) - вызов метода возможен только во время выполнения, т.к. у компилятора нет информации, чтобы проверить корректность такого вызова. В java это возможно при помощи рефлексии.

Статическое связывание используется для final, перегруженных, приватных, статических методов, в то время как динамическое связывание используется для разрешения переопределенных методов. Все абстрактные методы разрешаются при помощи динамического связывания.

В случае статического связывания используются не конкретные объекты, а информация о типе, то есть
 
используется тип ссылочной переменной. С другой стороны, при динамическом связывании для нахождения нужного метода используется конкретный объект.

SOLID
SOLID — это акроним, образованный из заглавных букв первых пяти принципов ООП и проектирования.

S(Single Responsibility Principle) - принцип единственной ответственности - каждый класс выполняет лишь одну задачу.
Легкая модификация в будущем, простое тестирование, класс не имеет зависимостей на другие классы.

O(Open Closed Principle) - принцип открытости/закрытости - программные сущности открыты для расширения и закрыты для модификации.
Чтобы не сломать логику в классе-родителе, мы унаследуемся от него и реализуем что-то своё, и используем свой класс.

L(Liskov’s Substitution Principle) - принцип подстановки барбары лисков - объекты в программе можно заменить их наследниками без изменения свойств программы.

I(Interface Segregation Principle) - принцип разделения интерфейса - много специализированных интерфейсов лучше, чем один общий

D(Dependency Inversion Principle) - принцип инверсии зависимостей - зависимость на абстракциях.
Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Использование: Создание интерфейсов и их реализаций. Пример: терминал оплаты(абстракция) и разные карты оплаты.


Java
Какая основная идея языка?
«Написано однажды - работает везде».
Идея основывается в написании одного кода, который будет работать на любой платформе.

За счет чего обеспечивается кроссплатформенность?
Кроссплатформенность была достигнута за счёт создания виртуальной машина Java. Java Virtual Machine или JVM - это программа, являющаяся прослойкой между операционной системой и Java программой. В среде виртуальной машины выполняются коды Java программ. Сама JVM реализована для разных ОС.
Что байт код для JVM может исполняться везде где установлена JVM. Код не нужно перекомпилировать под каждую из платформ.

Какие преимущества у java?
Объектно-ориентированное программирование
-	структура данных становится объектом, которым можно управлять для создания отношений между различными объектами.

Язык высокого уровня с простым синтаксисом и плавной кривой обучения
-	синтаксис Java основан на C ++, поэтому Java похожа на C. Тем не менее, синтаксис Java проще, что позволяет новичкам быстрее учиться и эффективнее использовать код для достижения конкретных результатов.

Стандарт для корпоративных вычислительных систем
-	корпоративные приложения — главное преимущество Java с 90-х годов, когда организации начали искать надежные инструменты программирования не на C.
 
Безопасность
-	благодарю отсутсвию указателей и Security Manager (политика безопасности, в которой можно указать правила доступа, позволяет запускать приложения Java в "песочнице").

Независимость от платформы
-	Можно создать Java-приложение на Windows, скомпилировать его в байт-код и запустить его на любой другой платформе, поддерживающей виртуальную машину Java (JVM). Таким образом, JVM служит уровнем абстракции между кодом и оборудованием.

Язык для распределенного программирования и комфортной удаленной совместной работы
-	Специфическая для Java методология распределенных вычислений называется Remote Method Invocation (RMI). RMI позволяет использовать все преимущества Java: безопасность, независимость от платформы и объектно- ориентированное программирование для распределенных вычислений. Кроме того, Java также поддерживает программирование сокетов и методологию распределения CORBA для обмена объектами между программами, написанными на разных языках.

Автоматическое управление памятью
Разработчикам Java не нужно вручную писать код для управления памятью благодаря автоматическому управлению памятью (AMM).

Многопоточность
Поток — наименьшая единица обработки в программировании. Чтобы максимально эффективно использовать время процессора, Java позволяет запускать потоки одновременно, что называется многопоточностью.

Стабильность и сообщество
Сообщество разработчиков Java не имеет себе равных. Около 45% респондентов опроса StackOverflow 2018 используют Java.

Какие недостатки у java?
Платное коммерческое использование (с 2019)

Низкая производительность
из-за компиляции и абстракции с помощью виртуальной машины, а также приложение очистки памяти.
Не развитые инструменты по созданию GUI приложений на чистой java. Многословный код
Java — это более легкая версия неприступного C ++, которая вынуждает программистов прописывать свои действия словами из английского языка. Это делает язык более понятным для неспециалистов, но менее компактным.

Что такое JDK? Что в него входит?
JDK (Java Development Kit) - включает JRE и набор инструментов разработчика приложений на языке Java:
-	компилятор Java (javac)
-	стандартные библиотеки классов java
-	примеры
-	документацию
-	различные утилиты

Что такое JRE? Что в него входит?
JRE (java Runtime Environment) - минимально-необходимая реализация виртуальной машины для исполнения Java-приложений. Состоит из JVM, ClassLoader и стандартного набора библиотек и классов Java
 
Что такое JVM?
JVM (Java Virtual Machine) - виртуальная машина Java исполняет байт-код Java, предварительно созданный из кода JIT компилятором, с помощью встроенного интерпретатора байткода.
HotSpot представляет собой реализацию концепции JVM.
Что такое byte code?
Байт-код Java — набор инструкций, скомпилированный компилятором, исполняемый JVM.

Что такое загрузчик классов (classloader)?
Используется для передачи в JVM скомпилированного байт-кода, хранится в файлах с расширением .class

При запуске JVM, используются три загрузчика классов:
- Bootstrap ClassLoader - базовый загрузчик
- загружает платформенные классы JDK из архива rt.jar

- AppClassLoader - системный загрузчик
- загружает классы приложения, определенные в CLASSPATH

- Extension ClassLoader - загрузчик расширений
-	загружает классы расширений, которые по умолчанию находятся в каталоге jre/lib/ext.

ClassLoader выполняет три основных действия в строгом порядке:
•	Загрузка: находит и импортирует двоичные данные для типа.
•	Связывание: выполняет проверку, подготовку и (необязательно) разрешение.
-	Проверка: обеспечивает правильность импортируемого типа.
-	Подготовка: выделяет память для переменных класса и инициализация памяти значениями по умолчанию.
-	Разрешение: преобразует символические ссылки из типа в прямые ссылки.
•	Инициализация: вызывает код Java, который инициализирует переменные класса их правильными начальными значениями.

Каждый загрузчик хранит указатель на родительский, чтобы суметь передать загрузку если сам будет не в состоянии этого сделать.

Что такое JIT?
JIT (Just-in-time compilation) - компиляция на лету или динамическая компиляция - технология увеличения производительности программных систем, использующих байт-код, путем компиляции байт-кода в машинный код во время работы программы.
В основном отвечает за оптимизацию производительности приложений во время выполнения. https://javahelp.online/osnovy/voprosy-otvety-sobesedovanie-java (Q13)

Что такое сборщик мусора? (Garbage collector)
Сборщик мусора выполняет две задачи:
-	поиск мусора;
-	очистка мусора.
Для обнаружения мусора есть два подхода:
-	Учет ссылок (Reference counting);
Учет ссылок - если обьект не имеет ссылок, он считается мусором.
Проблема - не возможность выявить циклические ссылки, когда два обьекта не имеют внешних ссылок, но ссылаются друг на друга -> утечка памяти
-	Трассировка (Tracing). (используется в HotSpot)6
Трассировка - до обьекта можно добраться из Корневых точке (GC root). До чего добраться нельзя - мусор.
Всё, что доступно из «живого» объекта, также является «живым».
Типы корневых точек (GC Roots) java приложения:
 
-	объекты в статических полях классов
-	объекты, доступные из стека потоков
-	объекты из JNI(java native interface) ссылок в native методах
Процессы сборки мусора разделяются несколько видов:
minor GC (малая) - частый и быстрый, работает только с областью памяти "young generation";
-	приложение приостанавливается на начало сборки мусора (такие остановки называются stop-the-world);
-	«живые» объекты из Eden перемещаются в область памяти «To»;
-	«живые» объекты из «From» перемещаются в «To» или в «old generation», если они достаточно «старые»;
-	Eden и «From» очищаются от мусора;
-	«To» и «From» меняются местами;
-	приложение возобновляет работу.
major GC (старшая) - редкий и более длительный, затрагивает объекты старшего поколения.
В принцип работы «major GC» добавляется процедура «уплотнения», позволяющая более эффективно использовать память. В процедуре живые объекты перемещаются в начало. Таким образом, мусор остается в конце памяти.
full GC (полная) - полный сборщик мусора сначала запускает Minor, а затем Major (хотя порядок может быть изменен, если старое поколение заполнено, и в этом случае он освобождается первым, чтобы позволить ему получать объекты от молодого поколения).

Виды ссылок в Java
1)	StrongReference — это самые обычные ссылки которые мы создаем каждый день, любая переменная ссылочного типа.
StringBuilder builder = new StringBuilder(); - builder это и есть strong-ссылка на объект StringBuilder.
2)	SoftReference — GC гарантировано удалит с кучи все объекты, доступные только по soft-ссылке, перед тем как бросит OutOfMemoryError. SoftReference это наш механизм кэширования объектов в памяти, но в критической ситуации, когда закончится доступная память, GC удалит не использующиеся объекты из памяти и тем самым попробует спасти JVM от завершения работы.
StringBuilder builder = new StringBuilder(); SoftReference<StringBuilder> softBuilder = new SoftReference(builder);

softBuilder.get() — вернет strong-ссылку на объект StringBuilder в случае если GC не удалил этот объект из памяти. В другом случае вернется null.
softBuilder.clear() — удалит ссылку на объект StringBuilder То же самое работает для WeakReference.
3)	WeakReference — если GC видит, что объект доступен только через цепочку weak-ссылок (исчезнули strong- ссылки), то он удалит его из памяти.
4)	PhantomReference — если GC видит что объект доступен только через цепочку phantom-ссылок, то он его удалит из памяти. После нескольких запусков GC.
Особенностей у этого типа ссылок две.
Первая это то, что метод get() всегда возвращает null. Именно из-за этого PhantomReference имеет смысл использовать только вместе с ReferenceQueue.
Вторая особенность – в отличие от SoftReference и WeakReference, GC добавит phantom-ссылку в ReferenceQueue после того как выполниться метод finalize().
5)	So in brief: Soft references try to keep the reference. Weak references don’t try to keep the reference. Phantom references don’t free the reference until cleared.
6)	ReferenceQueue. Он позволяет отслеживать момент, когда GC определит что объект более не нужен и его можно удалить. Именно сюда попадает Reference объект после того как объект на который он ссылается удален из памяти. При создании Reference мы можем передать в конструктор ReferenceQueue, в который будут помещаться ссылки после удаления.

Stack и Heap
Память процесса делится на Stack (стек) и Heap (куча) :
-	Stack содержит staсk frame'ы, они делятся на три части: параметры метода, указатель на предыдущий фрейм и локальные переменные.

-	Структура Heap зависит от выбранного сборщика мусора. Читай про GC!
 
MetaSpace - специальное пространство кучи, отделенное от кучи основной памяти. JVM хранит здесь весь статический контент. Это включает в себя все статические методы, примитивные переменные и ссылки на статические объекты. Кроме того, он содержит данные о байт-коде, именах и JIT-информации . До Java 7 String Pool также был частью этой памяти.
Вкратце, при Serial/Parallel/CMS GC будет следующая структура:
 
С помощью опций Xms и Xmx можно настроить начальный и максимально допустимый размер кучи соответственно. Существуют опции для настройки величины стека.

-	Heap - используется всем приложением, Stack - одним потоком исполняемой программы.
-	Новый обьект создается в heap, в stack размещается ссылка на него. В стеке размещаются локальные переменные примитивных типов.
-	Обьекты в куче доступны из любого места программы, стековая память не доступна для других потоков.
-	Если память стека закончилась JRE вызовет исключение StackOverflowError, если куча заполнена OutOfMemoryError
-	Размер памяти стека, меньше памяти кучи. Стековая память быстрее памяти кучи.
-	В куче есть ссылки между объектами и их классами. На этом основана рефлексия. Обе области хранятся в RAM.

Процедурная Java
Какие примитивные типы данных есть в Java?
Вещественные, целочисленные, логические и строковые. byte
short int long float double char
boolean

Что такое char?
16-разрядное беззнаковое целое, представляющее собой символ UTF-16 (буквы и цифры)

Сколько памяти занимает boolean?
Зависит от реализации JVM
В стандартной реализации Sun JVM и Oracle HotSpot JVM тип boolean занимает 4 байта (32 бита), как и тип int. Однако, в определенных версия JVM имеются реализации, где в массиве boolean каждое значение занимает по 1- му биту.
 
Что такое классы-обертки?
Обертка — это специальный класс, который хранит внутри себя значение примитива(объекты классов- оберток являются неизменяемыми (Immutable)).
Нужны для реализации дженериков.

Что такое автоупаковка и автораспаковка?
Автоупаковка - присвоение классу обертки значения примитивного типа; Автораспаковка - присвоение переменной примитивного типа значение класса обертки.
для присваивания ссылок-примитивов объектам их классов-оберток (и наоборот) не требуется ничего делать, все происходит автоматически.
Для того, чтобы иметь возможность оперировать с простыми числами (и boolean) как с объектами были придуманы классы-обёртки.

Что такое явное и неявное приведение типов? В каких случаях в java нужно использовать явное приведение?
Неявное приведение – автоматическое расширение типа переменной от меньшего к большему.
Явное приведение - явное сужение от большего к меньшему. Необходимо явно указать сужаемый тип.
В случае с объектами мы можем делать неявное(автоматическое) приведение от наследника к родителю, но не наоборот, иначе получим ClassCastException.

Что такое пул интов?
В Java есть пул(pool) целых чисел в промежутке [-128;127], так как это самый часто вречающийся диапазон. Т.е. если мы создаем Integer в этом промежутке, то вместо того, чтобы каждый раз создавать новый объект, JVM берет их из пула.
Изменить размер кэша в HotSpot вы можете, указав ключ -XX:AutoBoxCacheMax=<размер>.

Какие нюансы у строк в Java?
Класс String в Java - неизменяемый из-за модификатора final и отсутствия сеттера. Это нужно для реализации пула стрингов. При редактировании будет создаваться новая строка. При копировании новая строка не создается, а создается ссылка на существующую строку.

Что такое пул строк?
Область памяти где хранятся обьекты строк. При создании в пуле идет поиск строки:
-если НЕ находит - создается строка, возращается ссылка
-если находит - возращает ссылку найденной строки.

При этом использование оператора new заставляет класс String создать новый объект, даже если такая строка уже есть в пуле. После этого можем использовать метод intern(), чтобы поместить этот объект в пул строк.

Пул строк и Integer хранится в heap, но ссылки на объекты хранятся в stack.

Почему не рекомендуется изменять строки в цикле? Что рекомендуется использовать?
Т.к. строка неизменяемый класс, потребление ресурсов при редактировании, т.к. каждую итерацию при редактировании будет создаваться новый обьект строки. Рекомендуется использовать StringBuilder или StringBuffer.

Почему строки не рекомендуется использовать для хранения паролей?
1.	Пул строк
Так как строки в Java хранятся в пуле строк, то ваш пароль в виде обычного текста будет доступен в памяти, пока сборщик мусора не очистит её. И поскольку String используются в String pool для повторного использования,
 
существует довольно высокая вероятность того, что пароль останется в памяти надолго, что совсем не безопасно.

2.	Рекомендации авторов
Java сама по себе рекомендует использовать метод getPassword () из класса JPasswordField, который возвращает char [].

3.	Случайная печать в логах
С типом String всегда существует опасность того, что текст, хранящийся в строке будет напечатан в файле логов или в консоли. В то же время в случае использования Array, вы не будете печатать содержимое массива, а только его расположение в памяти.

Почему String неизменяемый и финализированный класс?
1.	Для возможности реализации строкового пула (String pool)
Виртуальная машина имеет возможность сохранить много места в памяти (heap space) т.к. разные строковые переменные указывают на одну переменную в пуле. При изменяемости строк было бы невозможно реализовать интернирование, поскольку если какая-либо переменная изменит значение, это отразится также и на остальных переменных, ссылающихся на эту строку.

2.	Безопасность
Изменяемость строк несло бы в себе потенциальную угрозу безопасности приложения. Поскольку в Java строки используются для передачи параметров для авторизации, открытия файлов и т.д. — неизменяемость позволяет избежать проблем с доступом.

3.	Для многопоточности. Неизменяемые строки потокобезопасны
Так как строка неизменяемая то, она безопасна для много поточности и один экземпляр строки может быть совместно использован различными потоками. Это позволяет избежать синхронизации для потокобезопасности. Таким образом, строки в Java полностью потокобезопасны.

4.	Ключ для HashMap
Поскольку строка неизменная, её hashcode кэшируется в момент создания и нет никакой необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в Map и его обработка будет быстрее, чем других ключей HashMap. Поэтому строка наиболее часто используется в качестве ключа HashMap.

-	можно передавать строку между потоками не опасаясь, что она будет изменена
-	отсутствуют проблемы с синхронизацией потоков
-	отсутствие проблем с утечкой памяти
-	отсутствие проблем с доступом и безопасностью при использовании строк для передачи параметров авторизации, открытия файлов и т.д.
-	кэширование hashcode
-	Экономия памяти при использовании пула строк для хранения повторяющихся строк.

Почему строка является популярным ключом в HashMap в Java?
Поскольку строки неизменны, их хэшкод кэшируется в момент создания, и не требует повторного пересчета.

Что делает метод intern() в классе String?
Помещает строку в pool строк.

Можно ли использовать строки в конструкции switch?
Да, начиная с Java 7 в операторе switch можно использовать строки, ранние версии Java не поддерживают этого.

Более подробно: https://javarush.ru/groups/posts/759-java-string-voprosih-k-sobesedovaniju-i-otvetih-na-nikh-ch1 (10) При этом:
-	участвующие строки чувствительны к регистру;
-	использование строк в конструкции switch делает код читабельнее, убирая множественные цепи условий if-else
 
-	оператор switch использует метод String.equals() для сравнения полученного значения со значениями case, поэтому добавьте проверку на NULL во избежание NullPointerException.

Какая основная разница между String, StringBuffer, StringBuilder?
String - неизменяемый, потокобезопасный; StringBuffer - изменяемый, потокобезопасный; StringBuilder - изменяемый, потоконебезопасный.

Существуют ли в java многомерные массивы?
Многомерные массивы в их классическом понимании в java не существуют.
Многомерный массив всегда прямоугольный и неразрывен в памяти. А то, что в java считается мнгомерным - в других языках ещё называют "зубчатым массивом" или массивом массивов.

Какими значениями инициируются переменные по умолчанию?
byte 0
short 0
int 0 long 0L float 0.0f
double 0.0d char '\u0000' boolean false Обьекты null
Локальные (в методе) переменные не имеют значений по умолчанию, их имеют поля класса.
Не static-поле класса будет инициализировано после того, как будет создан объект этого класса. А static-поле будет инициализировано тогда, когда класс будет загружен виртуальной Java машиной.

Что такое сигнатура метода?
Это имя метода плюс параметры (порядок параметров имеет значение из-за множественной передачи данных через троеточие, которое должно располагаться последним). В сигнатуру метода не входит возвращаемое значение, а также бросаемые им исключения.
А сигнатура метода в сочетании с типом возвращаемого значения и бросаемыми исключениями называется контрактом метода.

Расскажите про метод main
Является, как правило, точкой входа в программу и вызывается JVM.
Как только заканчивается выполнение метода main(), так сразу же завершается работа самой программы. static - чтобы JVM смогла загрузить его во время компиляции.
public static void и сигнатура - обязательное декларирование. Мэйнов может быть много и может не быть вообще.
Может быть перегружен.

Каким образом переменные передаются в методы, по значению или по ссылке?
Java передает параметры по значению. Всегда.
С примитивами, мы получаем копию содержимого. Со ссылками мы тоже получаем копию ссылки. https://javarush.ru/groups/posts/857-peredacha-parametrov-v-java

ООП в JAVA
Какие виды классов есть в java?
1.	Вложенные классы – нестатические классы внутри внешнего класса.
2.	Вложенные статические классы – статические классы внутри внешнего класса.
3.	Локальные классы Java – классы внутри методов. разница между локальным и внутреним
4.	Анонимные Java классы – классы, которые создаются на ходу. Анонимные классы доступно
5.	Final, abstract, enum - классы
 
Расскажите про вложенные классы. В каких случаях они применяются?
Нужны для обслуживания внешних классов

1.	Статические вложенные классы (Static nested classes)
o	Есть возможность обращения к внутренним статическим полям и методам класса обертки.
2.	Вложенные классы
o	Есть возможность обращения к внутренним полям и методам класса обертки.
o	Не может иметь статических объявлений.
o	Внутри такого класса нельзя объявить перечисления.
o	Если нужно явно получить this внешнего класса — OuterClass.this
3.	Локальный класс
o	Видны только в пределах блока, в котором объявлены.
o	Не могут быть объявлены как private/public/protected или static (по этой причине интерфейсы нельзя объявить локально).
o	Не могут иметь внутри себя статических объявлений (полей, методов, классов), но могут иметь константы (static final)
o	Имеют доступ к полям и методам обрамляющего класса.
o	Можно обращаться к локальным переменным и параметрам метода, если они объявлены с модификатором final или являются effectively final.
4.	Анонимные классы
o	Локальный класс без имени.

Что такое «локальный класс»? Каковы его особенности?
Данные классы объявляются внутри других методов. Они обладают всеми свойствами нестатического вложенного класса, только создавать их экземпляры можно только в методе.
Особенности:
Локальные классы способны работать только с final переменными метода.
С 8+ версий Java можно использовать не final переменные в локальных классах, но только при условии, что они не будут изменяться.
Локальные классы нельзя объявлять с модификаторами доступа. Локальные классы обладают доступом к переменным метода.
Может быть создан внутри блоков инициализации.

Что такое «анонимные классы»? Где они применяются?
Это вложенный локальный класс без имени, который разрешено декларировать в любом месте обрамляющего класса, разрешающем размещение выражений.
Создание экземпляра анонимного класса происходит одновременно с его объявлением. В зависимости от местоположения анонимный класс ведет себя как статический либо как нестатический вложенный класс - в нестатическом контексте появляется окружающий его экземпляр.

Анонимные классы имеют несколько ограничений:
Их использование разрешено только в одном месте программы - месте его создания;
Применение возможно только в том случае, если после порождения экземпляра нет необходимости на него ссылаться;
Реализует лишь методы своего интерфейса или суперкласса, т.е. не может объявлять каких-либо новых методов, так как для доступа к ним нет поименованного типа.

Анонимные классы обычно применяются для:
создания объекта функции (function object), например реализация интерфейса Comparator;
создания объекта процесса (process object), такого как экземпляры классов Thread, Runnable и подобных; в статическом методе генерации;
инициализации открытого статического поля final, которое соответствует сложному перечислению типов, когда для каждого экземпляра в перечислении требуется отдельный подкласс.

Анонимные классы всегда являются конечными классами.
 
Каждое объявление анонимного класса уникально. Видны только внутри того метода, в котором определены. В документации Oracle приведена хорошая рекомендация: «Применяйте анонимные классы, если вам нужен локальный класс для одноразового использования».

Каким образом из вложенного класса получить доступ к полю внешнего класса?
Статический вложенный класс имеет прямой доступ только к статическим полям обрамляющего класса. Простой вложенный класс, может обратиться к любому полю внешнего класса напрямую.

В случае, если у вложенного класса уже существует поле с таким же литералом, то обращаться к внешнему полю следует через имя внешнего класса. Например: Outer.this.field.

Что такое перечисления (enum)?
Перечисления представляют набор логически связанных констант.

Перечисление фактически представляет новый класс, поэтому мы можем определить переменную данного типа и использовать ее.

Перечисления, как и обычные классы, могут определять конструкторы, поля и методы.
Следует отметить, что конструктор по умолчанию приватный. Также можно определять методы для отдельных констант.
Методы:
-ordinal() возвращает порядковый номер определенной константы (нумерация начинается с 0)
-values() возвращает массив всех констант перечисления
Еnum имеет ряд преимуществ при использовании в сравнении с static final int.
Главным отличием является то что используя enum вы можете проверить тип данных. Недостатки
-	К ним не применимы операторы >, <, >=, <=
-	enum также требует больше памяти для хранения чем обычная константа.

Нужны для ограничения области допустимых значений: например, времена года, дни недели

Как проблема ромбовидного наследования решена в java?
В Java нет поддержки множественного наследования классов.

Предположим, что SuperClass — это абстрактный класс, описывающий некоторый метод, а классы ClassA и ClassB — обычные классы наследники SuperClass, а класс ClassC наследуется от ClassA и ClassB одновременно. Вызов метода родительского класса приведет к неопределенности, так как компилятор не знает о том, метод какого именно суперкласса должен быть вызван. Это и есть основная причина, почему в Java нет поддержки множественного наследования классов.

1.	Классы всегда побеждают: Определенный в классе / суперклассе метод всегда имеет высший приоритет перед дефолтными методами интерфейсов.
2.	Если не срабатывает правило 1, то побеждают саб-интерфейсы (more specific). Т.е. если интерфейс B наследует A, и у обоих есть методы с одинаковой сигнатурой, то побеждает B.
3.	Если оба правила не работают, то класс, наследующий конфликтующие интерфейсы, должен явно через super определить, какой именно метод вызвать, иначе компилятор будет сильно материться.

Что такое конструктор по умолчанию?
Если у какого-либо класса не определить конструктор, то компилятор сгенерирует конструктор без аргументов -
так называемый «конструктор по умолчанию».
Если у класса уже определен какой-либо конструктор, то конструктор по умолчанию создан не будет и, если он необходим, его нужно описывать явно.
 
Могут ли быть приватные конструкторы? Для чего они нужны?
Да, могут. Приватный конструктор запрещает создание экземпляра класса вне методов самого класса.
Нужен для реализации паттернов, например singleton.

Расскажите про классы-загрузчики и про динамическую загрузку классов.
При запуске JVM, используются три загрузчика классов:

-	Bootstrap ClassLoader - главный загрузчик
-	загружает платформенные классы JDK из архива rt.jar

-	AppClassLoader - системный загрузчик
-	загружает классы приложения, определенные в CLASSPATH

-	Extension ClassLoader - загрузчик расширений
-	загружает классы расширений, которые по умолчанию находятся в каталоге jre/lib/ext.

Динамическая загрузка происходит "на лету" в ходе выполнения программы с помощью статического метода класса Class.forName(имя класса). Для чего нужна динамическая загрузка? Например мы не знаем какой класс нам понадобится и принимаем решение в ходе выполнения программы передавая имя класса в статический метод forName().

Чем отличаются конструкторы по-умолчанию, конструктор копирования и конструктор с параметрами?
-У конструктора по умолчанию отсутствуют какие-либо аргументы.
-Конструктор копирования принимает в качестве аргумента уже существующий объект класса для последующего создания его клона.
-Конструктор с параметрами имеет в своей сигнатуре аргументы (обычно необходимые для инициализации полей класса).

Какие модификаторы доступа есть в Java? Какие применимы к классам?
Private – доступ к компоненту только из этого класса, в котором объявлен.
Default – Переменная или метод будут доступны для любого другого класса в том же пакете.
Protected – Поля protected доступны всем классам внутри пакета, а также всем классам-наследникам вне пакета.
Public – доступ к компоненту из экземпляра любого класса и любого пакета.
Класс может быть объявлен с модификатором public и default.

Что означает модификатор static?
Статическая переменная - это переменная, принадлежащая классу, а не объекту.
А статический класс- это вложенный класс, который может обращаться только к статическим полям обертывающего его класса.
Внутри static метода нельзя вызвать не статический метод по имени класса.


Может ли статический метод быть переопределён или перегружен?
Нельзя переопределять статические методы.
Если вы объявите такой же метод в классе-наследнике (subclass), т.е. метод с таким же именем и сигнатурой, вы лишь «спрячете» метод суперкласса вместо переопределения. Это явление известно как сокрытие
методов (hiding methods).
Перегружен - да. Всё работает точно так же как и с обычными методами - 2 статических метода могут иметь одинаковое имя, если количество их параметров или типов различается.

Могут ли нестатические методы перегрузить статические?
Да. Это будут просто два разных метода для программы. Статический будет доступен по имени класса.
 
Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?
При переопределении метода нельзя сузить модификатор доступа к методу (например, с public до private), но можно расширить.
Изменить тип возвращаемого значения нельзя, но можно сузить возвращаемое значение, если они совместимы. Например, если метод возвращает объект класса, а переопределенный метод возвращает класс- наследник.

Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы (throws и тп)?
В сигнатуре(имя + параметры) менять ничего нельзя.
Возможно расширение уровня доступа.
Изменять тип возвращаемого значения при переопределении метода разрешено только в сторону сужения типа (вместо родительского класса - наследника).
Секцию throws метода можно не указывать, но стоит помнить, что она остаётся действительной, если уже определена у метода родительского класса. Так же, возможно добавлять новые исключения, являющиеся наследниками от уже объявленных или исключения RuntimeException. Порядок следования таких элементов при переопределении значения не имеет.

Могут ли классы быть статическими?
Класс можно объявить статическим за исключением классов верхнего уровня.
Такие классы известны как «вложенные статические классы» (nested static class).

Что означает модификатор final? К чему он может быть применим?
Для класса это означает, что класс не сможет иметь подклассов, т.е. запрещено наследование. Следует также отметить, что к abstract-классам нельзя применить модификатор final, т.к. это взаимоисключающие понятия.
Для переменных примитивного типа это означает, что однажды присвоенное значение не может быть изменено
Для ссылочных переменных это означает, что после присвоения объекта, нельзя изменить ссылку на данный объект. Важно: Ссылку изменить нельзя, но состояние объекта изменять можно.
Т.к. массив – это объект, то final означает, что после присвоения ссылки на объект, уже нельзя ее изменить, но можно изменять состояние объекта.

Что такое абстрактные классы? Чем они отличаются от обычных?
Абстрактным называется класс, на основе которого не могут создаваться объекты. Как обычный класс, но с абстрактными методами.
Нельзя создать объект или экземпляр абстрактного класса. Наследниками абстрактного класса могут быть другие абстрактные классы

Может ли быть абстрактный класс без абстрактных методов?
Класс может быть абстрактным без единого абстрактного метода, если у него указан модификатор abstract.

Могут ли быть конструкторы у абстрактных классов? Для чего они нужны?
Да. Необходимы для наследников.
В абстрактном классе в Java можно объявить и определить конструкторы. Даже если вы не объявили никакого конструктора, компилятор добавит в абстрактный класс конструктор по умолчанию без аргументов. Абстрактные конструкторы будут часто использоваться для обеспечения ограничений класса или инвариантов, таких как минимальные поля, необходимые для настройки класса.
 
Что такое интерфейсы? Какие модификаторы по умолчанию имеют поля и методы интерфейсов?
Интерфейс — это план класса или, можно сказать, набор абстрактных методов и статических констант. В интерфейсе каждый метод является открытым и абстрактным, но не содержит конструктора. Таким образом, интерфейс в основном представляет собой группу связанных методов с пустыми телами. Другими
словами, интерфейс определяет как элементы будут взаимодействовать между собой.
- методы интерфейса являются публичными (public) и абстрактными (abstract),
- поля — public static final.

Чем интерфейсы отличаются от абстрактных классов? В каких случаях следует использовать абстрактный класс, а в каких интерфейс?
1.	Интерфейс описывает только поведение (методы) объекта, а вот состояний (полей) у него нет (кроме public static final), в то время как у абстрактного класса они могут быть.
2.	Мы можем наследовать только один класс, а реализовать интерфейсов — сколько угодно. Интерфейс может наследовать (extends) другой интерфейс/интерфейсы.
3.	Абстрактные классы используются, когда есть отношение "is-a", то есть класс-наследник расширяет базовый абстрактный класс, а интерфейсы могут быть реализованы разными классами, вовсе не связанными друг с другом.
4.	Абстрактный класс может реализовывать методы; интерфейс может реализовывать дефолтные методы начиная с 8й версии. https://javahelp.online/osnovy/voprosy-otvety-sobesedovanie-java (Q5)

Может ли один интерфейс наследоваться от другого? От двух других?
Да, может. Используется ключевое слово extends

Что такое дефолтные методы интерфейсов? Для чего они нужны?
В JDK 8 была добавлена такая функциональность как методы по умолчанию с модификатором default. И теперь интерфейсы могут иметь их реализацию по умолчанию, которая используется, если класс, реализующий данный интерфейс, не реализует метод. Это нужно для обратной совместимости.
(Если один или несколько методов добавляются к интерфейсу, все реализации также будут вынуждены их реализовывать. Методы интерфейса по умолчанию являются эффективным способом решения этой проблемы.)

Как решается проблема ромбовидного наследования при наследовании интерфейсов при наличии default методов?
класс, наследующий конфликтующие интерфейсы, должен явно через super определить, какой именно метод вызвать:
InterfaceB.super.method();

Каков порядок вызова конструкторов и блоков инициализации с учётом иерархии классов?
1.	Статические блоки от первого до последнего предка(от предка до наследника)
2.	Попарно динамической блок инициализации и конструктор от первого до последнего предка

Зачем нужны и какие бывают блоки инициализации?
Инициализация - это когда мы впервые задаем переменной какое-либо значение. Существуют статические и нестатические блоки инициализации.

Для чего в Java используются статические блоки инициализации?
Статические блоки инициализация используются для выполнения кода, который должен выполняться один раз при инициализации класса загрузчиком классов, в момент предшествующий созданию объектов этого класса при помощи конструктора. Такой блок принадлежит только самому классу.
 
Что произойдет, если в блоке инициализации возникнет исключительная ситуация?
Для нестатических блоков инициализации, если выбрасывание исключения прописано явным образом, требуется, чтобы объявления этих исключений были перечислены в throws всех конструкторов
класса. Иначе будет ошибка компиляции.
Для статического блока выбрасывание исключения в явном виде, приводит к ошибке компиляции.

Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?
Если возникшее исключение - наследник RuntimeException:
-для статических блоков инициализации будет выброшено java.lang.ExceptionInInitializerError;
-для нестатических будет проброшено исключение-источник.
Если возникшее исключение - наследник Error, то в обоих случаях будет выброшено java.lang.Error.
Если исключение: java.lang.ThreadDeath - смерть потока. В этом случае никакое исключение выброшено не будет.

Что такое класс Object?
Базовый класс для всех остальных объектов в Java. Любой класс наследуется от Object и, соответственно, наследуют его методы
Все классы являются наследниками суперкласса Object. Это не нужно указывать явно. В результате объект Object может ссылаться на объект любого другого класса.
Рефлексия (от позднелат. reflexio - обращение назад) - это механизм исследования данных о программе во время её выполнения.

Какие методы есть у класса Object (перечислить все)? Что они делают?
-	equals() - проверка на равенство двух обьектов
-	hashCode() - изначально случайно число int
-	toString() - представления данного объекта в виде строки.
-	getClass() - получение типа данного обьекта
-	clone() - клонирует объект методом.
-	finalize() - deprecated, вызывается GC перед удалением. (нет гарантии что будет вызван)

для многопоточки

-	notify() - «размораживает» одну случайную нить
-	notifyAll() - «размораживает» все нити данного монитора
-	wait() - нить освобождает монитор и «становится на паузу»
-	wait(long timeOut) - нить освобождает монитор и «становится на паузу»,принимает максимальное время ожидания в миллисекундах.
-	wait(long timeOut, int nanos) - нить освобождает монитор и «становится на паузу»,принимает максимальное время ожидания в миллисекундах, дополнительное время, в диапазоне наносекунд 0-999999.

Расскажите про equals и hashcode
Хеш-код — это целочисленный результат работы метода, которому в качестве входного параметра передан объект.
Если более точно, то это битовая строка фиксированной длины, полученная из массива произвольной длины.

Equals - это метод, определенный в Object, который служит для сравнения объектов. При сравнении объектов при помощи == идет сравнение по ссылкам. При сравнении по equals() идет сравнение по
состояниям объектов.

Свойства equals():
•	Симметричность: Для двух ссылок, a и b, a.equals(b) тогда и только тогда, когда b.equals(a)
•	Рефлексивность: для любого заданного значения x, выражение x.equals(x)
 
должно возвращать true.
Заданного — имеется в виду такого, что x != null
•	Постоянство: повторный вызов метода equals() должен возвращать одно и тоже значение до тех пор, пока какое-либо значение свойств объекта не будет изменено.
•	Транзитивность: Если a.equals(b) и b.equals(c), то тогда a.equals(c)
•	Совместимость с hashCode(): Два тождественно равных объекта должны иметь одно и то же значение hashCode()


При переопределении equals() обязательно нужно переопределить метод hashCode(). Равные объекты должны возвращать одинаковые хэш коды.

Каким образом реализованы методы hashCode() и equals() в классе Object?
1	- Реализация метода Object.equals() сводится к проверке на равенство двух ссылок:

public boolean equals(Object obj) { return (this == obj);
}

2	- HashCode реализован таким образом, что для одного и того же входного объекта, хеш-код всегда будет одинаковым.
Реализация метода Object.hashCode() описана как native, т.е. написана не на Java. Непереопределенный hashCode возвращает идентификационный хеш, основанный на состоянии потока, объединённого с xorshift (в OpenJDK8). А вообще, функция предлагает шесть методов на базе значения переменной hashCode.

0.	Случайно сгенерированное число.
1.	Функция адреса объекта в памяти.
2.	Жёстко запрограммированное значение 1 (используется при тестировании на чувствительность (sensitivity testing)).
3.	Последовательность.
4.	Адрес объекта в памяти, приведённый к целочисленному значению.
5.	Состояние потока, объединённое с xorshift (https://en.wikipedia.org/wiki/Xorshift) public native int hashCode();
Ситуация, когда у разных объектов одинаковые хеш-коды называется — коллизией. Вероятность возникновения коллизии зависит от используемого алгоритма генерации хеш-кода.

Зачем нужен equals(). Чем он отличается от операции ==?
equals() - сравнение по состоянию, == - по ссылкам

Правила переопределения equals()
1.	Проверить на равенство ссылки объектов this и параметра метода o. if (this == o) return true;
2.	Проверить, определена ли ссылка o, т. е. является ли она null.
Если в дальнейшем при сравнении типов объектов будет использоваться оператор instanceof, этот пункт можно пропустить, т. к. этот параметр возвращает false в данном случае null instanceof Object.
3.	Сравнить типы объектов this и o с помощью оператора instanceof или метода getClass(), руководствуясь описанием выше и собственным чутьем.
4.	Если метод equals переопределяется в подклассе, не забудьте сделать вызов super.equals(o)
5.	Выполнить преобразование типа параметра o к требуемому классу.
6.	Выполнить сравнение всех значимых полей объектов:
o для примитивных типов (кроме float и double), используя оператор ==
o для ссылочных полей необходимо вызвать их метод equals
o для массивов можно воспользоваться перебором по циклу, либо методом Arrays.equals()
 
o для типов float и double необходимо использовать методы сравнения соответствующих оберточных классов Float.compare() и Double.compare()

Что будет если переопределить equals() и не переопределить hashcode()
Нарушится контракт. Классы и методы, которые использовали правила этого контракта могут некорректно работать. Так для объекта HashMap это может привести к тому, что пара, которая была помещена в Map возможно не будет найдена в ней при обращении к Map, если используется новый экземпляр ключа.

Какой контракт между hashCode() и equals()?
1)	Если два объекта возвращают разные значения hashcode(), то они не могут быть равны
2)	Если equals объектов true, то и хэшкоды должны быть равны.
3)	Переопределив equals, всегда переопределять и hashcode.

Для чего нужен метод hashCode()?
вычисляет целочисленное значение для конкретного элемента класса, чтобы использовать его для быстрого поиска и доступа к этому элементу в hash-структурах данных, например, HashMap, HashSet и прочих.

Правила переопределения метода hashcode().
Если хеш-коды разные, то и входные объекты гарантированно разные. Если хеш-коды равны, то входные объекты не всегда равны.
При вычислении хэш-кода следует использовать те же поля, которые сравниваются в equals и которые не вычисляются на основе других значений.

-	вызов метода hashCode один и более раз над одним и тем же объектом должен возвращать одно и то же хэш- значение, при условии что поля объекта, участвующие в вычислении значения, не изменялись.
-	вызов метода hashCode над двумя объектами должен всегда возвращать одно и то же число, если эти объекты равны (вызов метода equals для этих объектов возвращает true).
-	вызов метода hashCode над двумя неравными между собой объектами должен возвращать разные хэш-значения. Хотя это требование и не является обязательным, следует учитывать, что его выполнение положительно повлияет на производительность работы хэш-таблиц.

Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode()?
Выбирать поля, которые с большой долью вероятности будут различаться. Для этого необходимо использовать уникальные, лучше всего примитивные поля, например такие как id, uuid. При этом нужно следовать правилу, если поля задействованы при вычислении hashCode(), то они должны быть задействованы и при выполнении equals().

Могут ли у разных объектов быть одинаковые hashCode()?
Когда у разных объектов одинаковые хеш-коды называется — коллизией.

Почему нельзя реализовать hashcode() который будет гарантированно уникальным для каждого объекта?
В Java множество возможных хэш кодов ограничено типом int, а множество объектов ничем не ограничено. Из-за этого, вполне возможна ситуация, что хэш коды разных объектов могут совпасть

Есть класс Point{int x, y;}. Почему хэш-код в виде 31 * x + y предпочтительнее чем x
+ y?
Множитель создает зависимость значения хэш-кода от очередности обработки полей, а это дает гораздо лучшую хэш-функцию.
 
Чем a.getClass().equals(A.class) отличается от a instanceOf A.class
getClass() получает только класс, а оператор instanceof проверяет является ли объект экземпляром класса или его потомком

Исключения
Что такое исключения?
Исключение — это ошибка (является объектом), возникающая во время выполнения программы.

Опишите иерархию исключений.
1.	класс Throwable (checked)

2.	от Throwable -> Error (ошибки JVM) и Exception (checked общие)

3.	от Exception
-	> RuntimeException (unchecked)
-	> IOException, SQLException, ReflectiveOperationException (checked)

4.	RuntimeException (unchecked):
ClassCastExceptiuon IndexOutOfBoundException AritthmeticException NullPointerException
checked - зависит от программиста, unchecked - от программиста не зависит

Расскажите про обрабатываемые и необрабатываемые исключения
1.	Checked исключения, это те, которые должны обрабатываться блоком catch или описываться в сигнатуре метода. Unchecked могут не обрабатываться и не быть описанными.
2.	Unchecked исключения в Java — наследованные от RuntimeException, checked — от Exception.
Checked исключения отличаются от Unchecked исключения в Java, тем что наличие\обработка Checked исключения проверяются компилятором на этапе компиляции. Наличие\обработка Unchecked исключения происходит на этапе выполнения.

Можно ли обработать необрабатываемые исключения?
Можно, чтобы в некотрых случаях программа не прекратила работу

Какой оператор позволяет принудительно выбросить исключение?
Throw

О чем говорит ключевое слово throws?
Метод потенциально может выбросить исключение с указанным типом. Передаёт обработку исключения вышестоящему методу.

Как создать собственное («пользовательское») исключение
Необходимо унаследоваться от базового класса требуемого типа исключений (например, от Exception или RuntimeException).
и переопределит методы

Расскажите про механизм обработки исключений в java (Try-catch-finally)
Try - блок в котором может появиться исключение;
Catch - блок в котором мы указываем исключение и логику его обработки;
Finally - блок который обязательно отработает
 
Возможно ли использование блока try-finally (без catch)?

try может быть в паре с finally, без catch. Работает это точно так же - после выхода из блока try выполняется блок finally

Может ли один блок catch отлавливать сразу несколько исключений?
Да

Всегда ли выполняется блок finally? Существуют ли ситуации, когда блок finally не будет выполнен?
Да, кроме случаев завершения работы программы или JVM:

1	- Finally может не выполниться в случае если в блоке try вызывает System.exit(0),
2	- Runtime.getRuntime().exit(0), Runtime.getRuntime().halt(0) и если во время исполнения блока try виртуальная машина выполнила недопустимую операцию и будет закрыта.
3	- В блоке try{} бесконечный цикл.

Может ли метод main() выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?
Может и оно будет передано в виртуальную машину Java (JVM). Для случая с методом main произойдет две вещи:

-	будет завершен главный поток приложения;
-	будет вызван ThreadGroup.uncaughtException.

В каком порядке следует обрабатывать исключения в catch блоках?
От наследника к предку

Что такое механизм try-with-resources?
Дает возможность объявлять один или несколько ресурсов в блоке try, которые будут закрыты автоматически без использования finally блока.
В качестве ресурса можно использовать любой объект, класс которого реализует интерфейс java.lang.AutoCloseable или java.io.Closeable.

Что произойдет если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из блока finally?
finally-секция может «перебить» throw/return при помощи другого throw/return

Что произойдет если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из метода close() при использовании try-with- resources?
В try-with-resources добавленна возможность хранения "подавленных" исключений, и брошенное try-блоком исключение имеет больший приоритет, чем исключения получившиеся во время закрытия.

Сериализация и копирование
Что такое сериализация и как она реализована в Java?
Сериализация это процесс сохранения состояния объекта в последовательность байт; Реализована через интерфейс - маркер Serializable.

Для чего нужна сериализация?
Для компактного сохранения состояния объекта и считывание этого состояния
 
Опишите процесс сериализации/десериализации с использованием Serializable.
1)	Класс объекта должен реализовывать интерфейс Serializable
2)	Создать поток ObjectOutputStream (oos), который записывает объект в переданный OutputStream.
3)	Записать в поток: oos.writeObject(Object);
4)	Сделать oos.flush() и oos.close()

Как изменить стандартное поведение сериализации/десериализации?
Использовать интерфейс Externalizable. Переопределить методы writeExternal(ObjectOutput out) throws IOException
readExternal(ObjectInput in) throws IOException, ClassNotFoundException

Какие поля не будут сериализованы при сериализации? Будет ли сериализовано final поле?
1)	Добавить к полю модификатор transient. В таком случае после восстановления его значение будет null.
2)	Сделать поле static. Значения статических полей автоматически не сохраняются.
3)	Поля с модификатором final сериализуются как и обычные. За одним исключением – их невозможно десериализовать при использовании Externalizable, поскольку final-поля должны быть инициализированы в конструкторе, а после этого в readExternal изменить значение этого поля будет невозможно. Соответственно, если необходимо сериализовать объект с final-полем неоходимо использовать только стандартную сериализацию.

Как создать собственный протокол сериализации?
Для создания собственного протокола нужно просто переопределить writeExternal() и readExternal().
В отличие от двух других вариантов сериализации, здесь ничего не делается автоматически. Протокол полностью в ваших руках.

Какая роль поля serialVersionUID в сериализации?
Поле private static final long serialVersionUID содержит уникальный идентификатор версии сериализованного класса. Оно вычисляется по содержимому класса - полям, их порядку объявления, методам, их порядку объявления. Соответственно, при любом изменении в классе это поле поменяет свое значение.
Если мы не объявляем его явно, Java делает это за нас.

Когда стоит изменять значение поля serialVersionUID?
Вы должны изменить serialVersionUID только тогда, когда вы сознательно хотите нарушить совместимость со всеми существующими сериализациями , например, когда изменения в вашем классе сделают его настолько семантически отличным, что у вас не будет выбора - в этом случае вы действительно должны несколько раз подумать о том, что вы на самом деле делаете.

В чем проблема сериализации Singleton?
-	Проблема -
в том что после десериализации мы получим другой объект.
Таким образом, сериализация дает возможность создать Singleton еще раз, что не совсем нужно.
-	Решение -
В классе определяется метод с сигнатурой
"Object readResolve() throws ObjectStreamException"
-	Назначение -
этого метода - возвращать замещающий объект вместо объекта, на котором он вызван.

Расскажите про клонирование объектов.
в Java, есть 3 способа клонирования объекта:
1.	С использованием интерфейса Cloneable;
Первый способ подразумевает, что вы будете использовать механизм так называемого «поверхностного клонирования» и сами позаботитесь о клонировании полей-объектов. Метод clone() в родительском классе Object
 
является protected, поэтому требуется переопределение его с объявлением как public. Он возвращает экземпляр объекта с копированными полями-примитивами и ссылками. И получается что у оригинала и его клона поля- ссылки указывают на одни и те же объекты.
2.	С использованием конструктора клонирования объекта;
В классе описывается конструктор, который принимает объект этого же класса и инициализирует значениями его полей поля нового объекта.
3.	С использованием сериализации.
Он заключается в сохранении объекта в поток байтов с последующей эксгумацией его от туда.

В чем отличие между поверхностным и глубоким клонированием?
Поверхностное копирование копирует настолько малую часть информации, насколько это возможно. По умолчанию, клонирование в Java является поверхностным, т.е. Object class не знает о структуре класса, которого он копирует.
Глубокое копирование дублирует все. Глубокое копирование — это две коллекции, в одну из которых дублируются все элементы оригинальной коллекции

Какой способ клонирования предпочтительней?
Наиболее безопасным и следовательно предпочтительным способом клонирования является использование специализированного конструктора копирования:
Отсутствие ошибок наследования (не нужно беспокоиться, что у наследников появятся новые поля, которые не будут склонированы через метод clone());
Поля для клонирования указываются явно; Возможность клонировать даже final поля.

Почему метод clone() объявлен в классе Object, а не в интерфейсе Cloneable?
Метод clone() объявлен в классе Object с сигнатурой native, чтобы обеспечить доступ к стандартному механизму "поверхностного копирования" объектов (копируются значения всех полей, включая ссылки на сторонние объекты); он объявлен, как protected, чтобы нельзя было вызвать этот метод у не переопределивших его объектов.

Как создать глубокую копию объекта? (2 способа)
Глубокое клонирование требует выполнения следующих правил:
-Нет необходимости копировать отдельно примитивные данные;
-Все классы-члены в оригинальном классе должны поддерживать клонирование. Для каждого члена класса должен вызываться super.clone() при переопределении метода clone();
-Если какой-либо член класса не поддерживает клонирование, то в методе клонирования необходимо создать новый экземпляр этого класса и скопировать каждый его член со всеми атрибутами в новый объект класса, по одному.
1	Сериализация – это еще один способ глубокого копирования. Мы просто сериализуем нужный объект и десериализуем его. Очевидно, объект должен поддерживать интерфейс Serializable. Мы сохраняет объект в массив байт и потом прочитать из него.
2	При помощи библиотеки DeepCloneable
Глубокое клонирование с этой библиотекой сводится с двум строкам кода: Cloner cloner = new Cloner();
DeepCloneable clone = cloner.deepClone(this);


Дженерики
Что такое дженерики?

"Дженерики – это параметризованные типы. С их помощью можно объявлять классы, интерфейсы и методы, в которых тип данных указан в виде параметра. Используя дженерики, можно создать единственный класс, который будет автоматически работать с разными типами данных. Эта информация доступна только на этапе компиляции и стирается в runtime, и в байт код попадет только информация о том, что в программе есть некий список List<Object> list вместо List<String> list, например. Появились в версии 1.5 " на "9"
 
Для чего нужны дженерики?
Для строгой типизации и проверки на этапе компиляции.
Дженерики позволяют передавать тип объекта компилятору в форме <тип>. Таким образом, компилятор может выполнить все необходимые действия по проверке типов во время компиляции, обеспечивая безопасность по приведению типов во время выполнения.

Что такое сырые типы (raw type)?
Сырые типы — это типы без указания типа в фигурных скобках ( List list = new ArrayList<>() ), они использовались до появления дженериков.
Не указывая их, под капотом используется Object.

Что такое вайлдкарды?
Маске (wildcard) можно задать ограничения:
-“? extends T” (для получения в методе) - объект, который наследуется от Т, либо сам Т – ковариантность.
Если контейнер объявлен ? extends T, то можно только читать значения. В список нельзя ничего добавить, кроме null.
-“? super T” (для отдачи в методе) - любой объект подтипа Т, включая Т – контравариантность. Нельзя прочитать элемент из контейнера с wildcard ? super, кроме объекта класса Object

При использовании ? мы сообщаем компилятору, чтобы он игнорировал информацию о типе, т.е. <?> - неограниченный символ подстановки. <?> означает то же что и <? extends Object>, т.е. принимает всё. Это можно обойти, создав обобщенный метод, объявленный с переменной типа T.

Расскажите про принцип PECS
Producer Extends Consumer Super wildcard подстановочный знак:
Если мы объявили wildcard с extends, то это producer. Он только «производит», предоставляет элемент из контейнера, а сам ничего не принимает.
Если же мы объявили wildcard с super — то это consumer. Он только принимает, а предоставить ничего не может.

Иначе говоря:
Если вы только получаете объекты из дженерик-коллекции - это producer и надо использвовать extends. Если вы только кладете объекты в коллекцию - это consumer и надо использовать super.
Если вы делаете оба эти действия, то не надо использовать ни super, ни extends.

Коллекции
Что такое «коллекция»?
Коллекция – это объект, который содержит набор объектов одного типа. Каждый из этих объектов в коллекции называется элементом.
 
Расскажите про иерархию коллекций

Почему Map — это не Collection, в то время как List и Set являются Collection?
Коллекция (List и Set) представляет собой совокупность некоторых элементов (обычно экземпляров одного класса).Map -это совокупность пар "ключ"-"значение".
У map нет итерабл, не понятно по чему проводить итерацию

В чем разница между java.util.Collection и java.util.Collections?
Класс java.util.Collections содержит исключительно статические методы для работы с коллекциями. В них входят методы, реализующие полиморфные алгоритмы (такие алгоритмы, использование которых возможно с разными видами структур данных), "оболочки", возвращающие новую коллекцию с инкапсулированной указанной структурой данных и некоторые другие методы.
java.util.Collection - это корневой интерфейс Java Collections Framework. Этот интерфейс в основном применяется там, где требуется высокий уровень абстракции, например, в классе java.util.Collections.

Какая разница между итераторами с fail-fast и fail-safe поведением? (С примерами)
Итератор fail-safe не вызывает исключений при изменении структуры коллекции, потому что работает с её клоном.
Пример fail-safe - CopyOnWriteArrayList и итератор keySet коллекции ConcurrentHashMap.

Итератор fail-fast генерирует исключение ConcurrentModificationException, если коллекция меняется во время итерации, но работает быстрее.
Пример fail-fast - Vector и Hashtable.

Чем различаются Enumeration и Iterator?
Iterator имеет больше методов работы с коллекциями и был специально введен в java2, вместо Enumeration(interface). Рекоммендуется юзать Iterator.
 
Оба интерфейса предназначены для обхода коллекции, но есть различия:
-с помощью Enumeration нельзя добавлять/удалять элементы;
-в Iterator исправлены имена методов для повышения читаемости кода (Enumeration.hasMoreElements() соответствует Iterator.hasNext(), Enumeration.nextElement() соответствует Iterator.next() и т.д);
-Enumeration присутствуют в устаревших классах, таких как Vector/Stack, тогда как Iterator есть во всех современных коллекциях.

Как между собой связаны Iterable, Iterator и «for-each»?
Интерфейс Iterable имеет метод - iterator(), с типом возвращаемого значения - интерфейс Iterator. Экземпляры классов, реализующих интерфейс Iterable, могут использоваться в цикле foreach.

Можно ли итерируясь по ArrayList удалить элемент? Какое вылетит исключение?
Можно, но нужно использовать iterator.remove().
Иначе при прохождении по ArrayList в цикле for сразу после удаления элемента будет ConcurrentModificationException

Как поведёт себя коллекция, если вызвать iterator.remove()?
Этот метод удаляет текущий элемент. Важный момент заключается в том, что сначала этот элемент необходимо получить с помощью метода next(), если мы вызовем метод remove() до метода next(), то мы получим IllegalStateException.

Чем Set отличается от List?
Set не добавляет новых методов, только вносит изменения унаследованные.
В частности, метод add() добавляет элемент в коллекцию и возвращает true, если не было такого элемента. Разрешено наличие только одной ссылки типа null.

Расскажите про интерфейс Set.
Интерфейс Set расширяет интерфейс Collection.
Set не добавляет новых методов, только вносит изменения унаследованные. Set - неупорядоченный набор неповторяющихся элементов
В частности, метод add() добавляет элемент в коллекцию и возвращает true, если не было такого элемента. Разрешено наличие только одной ссылки типа null.

Расскажите про реализации интерфейса Set
В HashSet порядок добавления элементов будет непредсказуемым - используется хэширование для ускорения выборки.
В TreeSet объекты хранятся отсортированными по возрастанию из-за применения к/ч дерева. LinkedHashSet хранит элементы в порядке добавления.

В чем отличия TreeSet и HashSet?
HashSet быстрее, чем TreeSet .
В HashSet элементы в случайном порядке, в TreeSet в отсортированном.
HashSet обеспечивает постоянную производительность - О(1) - для большинства операций, таких как add () , remove () и contains () , по сравнению с временем log(n), предлагаемым TreeSet.

Чем LinkedHashSet отличается от HashSet?
Основное различие в том, что LinkedHashSet сохраняет порядок вставки элементов, а HashSet - нет. В основе LinkedHashSet лежит LinkedHashMap вместо HashMap. Благодаря этому порядок элементов при обходе коллекции является идентичным порядку добавления элементов

Что будет, если добавлять элементы в TreeSet по возрастанию?
TreeSet все равно в каком порядке вы добавляете в него элементы, так как в основе TreeSet лежит красно-черное дерево, которое умеет само себя балансировать и хранить элементы по возрастанию.
 
Как устроен HashSet, сложность основных операций.
Все классы, реализующие интерфейс Set, внутренне поддерживаются реализациями Map. HashSet хранит элементы с помощью HashMap. Значение, которые мы передаем в HashSet, является ключом к объекту HashMap, а в качестве значения используется Object.
 

Как устроен LinkedHashSet, сложность основных операций.
В его основе лежит LinkedHashMap. Благодаря этому порядок элементов при обходе коллекции является идентичным порядку добавления элементов

Как устроен TreeSet, сложность основных операций.
Время для базовых операций - Логарифмическое время.
Гарантирует порядок элементов - в основе лежит красно-черное дерево, которое умеет само себя балансировать.
Не предоставляет каких-либо параметров для настройки производительности
Предоставляет дополнительные методы для упорядоченного списка: first(), last(), headSet(), tailSet()

Расскажите про интерфейс List
Контейнеры List хранит элементы в порядке добавления. Интерфейс List дополняет Collection несколькими методами, обеспечивающими вставку и удаление элементов в середине списка.

Как устроен ArrayList, сложность основных операций.
ArrayList реализован внутри в виде обычного массива. Поэтому при вставке элемента в середину, приходится сначала сдвигать на один все элементы после него, а уже затем в освободившееся место вставлять новый элемент. Механизм автоматического «расширения» массива существует, а вот автоматического «сжатия» нет, можно только явно выполнить «сжатие» командой trimToSize()
 
 

Что такое Queue?
Queue - коллекция, предназначенная для хранения элементов в порядке, нужном для их обработки. Очереди обычно, но не обязательно, упорядочивают элементы в FIFO (first-in-first-out) порядке.

Что такое Deque? Чем отличается от Queue?
Deque - двухстороняя очередь, расширяет queue. Он отличается от Queue тем, что можно добавлять и удалять элементы как в хвосте так и в голове. Количество методов удваивается. Пример:
addFirst(E e); addLast(E e);
Помимо этого реализации интерфейса Deque могут строится по принципу FIFO, либо LIFO.
Реализации и Deque, и Queue обычно не переопределяют методы equals() и hashCode(), а используются методы класса Object, основанные на сравнении ссылок.
Рекомендуется использовать вместо устравшего Stack. Приведите пример реализации Deque.
Linked list, Stack, ArrayDeque

Какая коллекция реализует FIFO?
Queue

Какая коллекция реализует LIFO?
Vector, ArrayDeque

Оцените количество памяти на хранение одного примитива типа byte в LinkedList?
Каждый элемент LinkedList хранит ссылку на предыдущий элемент, следующий элемент и ссылку на данные. Для x32 систем каждая ссылка занимает 32 бита (4 байта). Сам объект типа Node занимает приблизительно 8 байт. Размер каждого объекта в Java кратен 8, соответственно получаем 24 байта. Примитив типа byte занимает 1 байт памяти, но в списке примитивы упаковываются, соответственно получаем еще 8 байт. Таким образом, в x32 JVM около 32 байтов выделяется для хранения одного значения типа byte в LinkedList.

Для 64-битной JVM каждая ссылка занимает 64 бита (8 байт). Вычисления аналогичны. Посчитать на других переменных!

Оцените количество памяти на хранение одного примитива типа byte в ArrayList?
ArrayList основан на массиве. Каждый элемент массива хранит примитивный тип данных - byte, размер которого 1 байт.

Какие существуют реализации Map?
TreeMap, HashMap, HashTable, LinkedHashMap

Как устроена HashMap, сложность основных операций? (Расскажите про принцип корзин)
HashMap – внутри состоит из корзин и списка элементов, на которые ссылаются корзины. Корзины – массив
Элементы(Node) – связанный список, то есть каждый элемент списка имеет указатель на следующий элемент. При добавлении нового элемента, хэш-код ключа определяет корзину для элемента с помощью hashFunction(),
 
который принимает hashCode ключа и возвращает номер корзины. В корзине есть ссылка на связанный список, в который будет положен наш объект. Идет проверка, есть ли элементы в этом списке. Если нету, то корзина получает ссылку нового элемента, если есть, то происходит прохождение по списку элементов и сравнивание элементов в списке. Проверяется равенство hashcode. Зная о коллизии, проводится еще сравнивание ключей методом equals.
Если оба равны: идет перезапись
Если не равен equals: добавляется элемент в конец списка

HashMap имеет поле loadFactor. Оно может быть задано через конструктор. По умолчанию - 0.75. Его произведение на количество корзин дает нам необходимое число объектов которое нужно добавить чтобы состоялось удвоение количества корзин.
Например если у нас мапка с 16-ю(default) корзинами, а loadFactor равняется 0.75, то расширение произойдет когда мы добавим 16 * 0.75 = 12 объектов.
После удвоения все объекты будут перераспределены с учетом нового количества корзин

Как устроена TreeMap, сложность основных операций?
Класс TreeMap<K, V> представляет отображение в виде дерева. Он наследуется от класса AbstractMap и реализует интерфейс NavigableMap, а следовательно, также и интерфейс SortedMap. Поэтому в отличие от коллекции HashMap в TreeMap все объекты автоматически сортируются по возрастанию их ключей.

Как работает HashMap при попытке сохранить в него два элемента по ключам с одинаковым hashCode(), но для которых equals() == false?
По значению hashCode() вычисляется индекс ячейки массива, в список которой этот элемент будет добавлен. Перед добавлением осуществляется проверка на наличие элементов в этой ячейке. Если элементы с таким hashCode() уже присутствует, но их equals() методы не равны, то элемент будет добавлен в конец списка.

Что будет, если мы кладем в HashMap ключ, у которого equals и hashCode определены некорректно?
Объект скорее всего добавится, но обратно мы не сможем получить его.

Возможна ли ситуация, когда HashMap выродится в список даже с ключами имеющими разные hashCode()?
Это возможно в случае, если метод, определяющий номер корзины будет возвращать одинаковые значения.

Почему нельзя использовать byte[] в качестве ключа в HashMap?
Хэш-код массива не зависит от хранимых в нем элементов, а присваивается при создании массива (метод вычисления хэш-кода массива не переопределен и вычисляется по стандартному Object.hashCode() на основании
 
адреса массива). Также у массивов не переопределен equals и выполняется сравнение указателей. Это приводит к тому, что обратиться к сохраненному с ключом-массивом элементу не получится при использовании другого массива такого же размера и с такими же элементами, доступ можно осуществить лишь в одном случае — при использовании той же самой ссылки на массив, что использовалась для сохранения элемента.

Будет ли работать HashMap, если все добавляемые ключи будут иметь одинаковый hashCode()?
Да, будет, но в этом случае HashMap вырождается в связный список и теряет свои преимущества.

Какое худшее время работы метода get(key) для ключа, которого нет в HashMap?
O(N). Худший случай - это поиск ключа в таблице, вырожденной в список, перебор ключей которой занимает линейно пропорциональное время количеству хранимых элементов.

Какое худшее время работы метода get(key) для ключа, который есть в HashMap?
O(N) – линейное

Начальная ёмкость коллекций

Функциональные интерфейсы
Что такое функциональный интерфейс?
Это интерфейс, который содержит только 1 абстрактный метод.
Интерфейс может включать сколько угодно default (и static) методов и при этом оставаться функциональным, потому что default методы - не абстрактные.

Для чего нужна аннотация @FunctionalInterface?
Нужна чтобы точно определить интерфейс как функциональный. Она обозначит замысел и не даст определить второй абстрактный метод в интерфейсе.

Какие встроенные функциональные интерфейсы вы знаете?
Predicate<T> - реализуется функция, получающая на вход экземпляр класса T и возвращающая на выходе значение типа boolean

Consumer<T> - реализуется функция, которая получает на вход экземпляр класса T, производит с ним некоторое действие и ничего не возвращает
 
Function<T,R> - реализуется функция, получающая на вход экземпляр класса T и возвращающая на выходе экземпляр класса R

Supplier<T> - реализуется функция, ничего не принимающая на вход, но возвращающая на выход результат класса T

UnaryOperator<T> - принимает в качестве параметра объект типа T, выполняет над ними операции и возвращает результат операций в виде объекта типа T

BinaryOperator<T, Т> - реализуется функция, получающая на вход два экземпляра класса T и возвращающая на выходе экземпляр класса T

Что такое ссылка на метод?
Ссылка на статический метод - ContainingClass::staticMethodName
Ссылка на нестатический метод конкретного объекта - containingObject::instanceMethodName Ссылка на конструктор - ClassName::new
Ссылка на метод - это сокращенный синтаксис выражения лямбда, который выполняет только один метод. Это позволяет нам ссылаться на конструкторы или методы, не выполняя их.

Что такое лямбда-выражение? Чем его можно заменить?
Лямбда-выражение - упрощённая запись анонимного класса, реализующего функциональный интерфейс

Stream API
Что такое Stream API? Для чего нужны стримы?
Интерфейс java.util.Stream представляет собой последовательность элементов, над которой можно производить различные операции.
Операции над стримами бывают или промежуточными или терминальными. Терминальные операции возвращают результат определенного типа, а промежуточные операции возвращают тот же стрим. Таким образом вы можете строить цепочки из несколько операций над одним и тем же стримом.
Его задача - упростить работу с наборами данных, в частности, упростить операции фильтрации, сортировки и другие манипуляции с данными.

Почему Stream называют ленивым?
Методы не будут выполняться пока не будет вызван терминальный метод

Какие существуют способы создания стрима?
Пустой стрим: Stream.empty() Стрим из List: list.stream()
Стрим из Map: map.entrySet().stream() Стрим из массива: Arrays.stream(array)
Стрим из указанных элементов: Stream.of("1", "2", "3")
-Можно получить из BufferedReader при помощи метода lines(), который вернет поток строк из потока символов.
-Из директории на диске при помощи методов Files.list() и Files.walk()
-Можно получить из строки методом chars(), будет IntStream с символами.
-Можно порождать динамически, генерировать при помощи supplier.
-Итерированием какой-то функции
-Можно получить диапазон чисел в виде стрима range и rangeClosed
-Конкатенацией других стримов

Как из коллекции создать стрим?
Collection<String> collection = Arrays.asList("a1", "a2", "a3"); Stream<String> streamFromCollection = collection.stream();
 
Какие промежуточные методы в стримах вы знаете?
filter(boolean - Predicate) map()
flatMap() limit(n) skip(n)
concat(Stream s1, Stream s2) peek(someFunction) distinct()
sorted()

Расскажите про метод peek().
Предполагается, что map() получает на вход один объект, а возвращает другой. Возможно, того же типа, но другой. peek() - это частный случай map(), который возвращает тот же самый объект, который получил на входе, возможно, с изменённым внутренним состоянием. Конечно, можно использовать для этого map(), но есть нюансы. Во-первых, peek() на одну строчку короче - не нужно писать return, Java и так знает, что нужно возвращать. Во-вторых, вы страхуетесь от ошибок - из peek() невозможно вернуть не тот объект, который пришёл на вход.

Расскажите про метод map().
Метод map() заданным образом преобразует каждый элемент стрима, потом преобразует все объекты в итоговый стрим.

Расскажите про метод flatMap().
flatMap возвращает по стриму для каждого объекта в первоначальном стриме, а затем результирующие потоки объединяются в исходный стрим.

Чем отличаются методы map() и flatMap().
map для каждого объекта в стриме возвращает по 1 объекту, потом преобразует все объекты в итоговый стрим. flatMap возвращает по стриму для каждого объекта в первоначальном стриме, а затем результирующие потоки объединяются в исходный стрим.

Расскажите про метод filter()
фильтрует стрим, возвращая только те элементы, что проходят по условию (Predicate) Проверяет значение на “true” и “false”

Расскажите про метод limit()
limit(n) - возвращает новый поток, ограниченный n-результатами Расскажите про метод skip()
skip(n) - возвращает новый поток, пропуская первые n элементов

Расскажите про метод sorted()
sorted() - возвращает отсортированный поток

Расскажите про метод distinct()
distinct() - возвращает поток равнозначный исходному, но без дубликатов

Какие терминальные методы в стримах вы знаете?
-forEach – принимает consumer, которому будут выведены элементы стрима.
-forEachOrdered – как и forEach, но гарантирует порядок.
-count() - подсчет всех значений
-max() - возвращает максимальный элемент
-min() - возвращает минимальный элемент
-findAny() - находится вхождение – сразу возвращает результат
 
-anyMatch() проверяет на наличие совпадения
-allMatch() – возвращает boolean
-noneMatch() – возвращает boolean
-findFirst – возвращает первый элемент из стрима, возвращается OptionalInt
-collect – собирает элементы в новое хранилище
-reduce – результат применения бинарного оператора к каждой паре элементов стрима, пока не останется один элемент.
-toArray - возвращет массив

Терминальный метод можно вызвать только один раз.
Все оконечные методы возвращают Optional - оболочка ответа (этот специальный тип ввели чтобы не возвращать null)

Расскажите про метод collect()
Stream.collect () является одним из терминальных методов. Это позволяет выполнять изменяемые операции свертывания (переупаковка элементов в некоторые структуры данных и применение некоторой дополнительной логики, объединение их и т. Д.)
Преобразует стрим в коллекцию

Расскажите про метод reduce()
позволяет выполнять агрегатные функции и возвращать один результат.
-
Результат применения бинарного оператора к каждой паре элементов стрима, пока не останется один элемент.

Расскажите про класс Collectors и его методы.
Нужен для того, чтобы упаковывать стримы в коллекции:
toList() - преобразует поток в список — List<T> toSet() - преобразует поток в список — Set<T> toMap() - преобразует поток в список — Map<K, V> Используются в методе collect().

Расскажите о параллельной обработке в Java 8.
Чтобы сделать обычный последовательный поток параллельным, надо вызвать у объекта Stream метод parallel. А обратный метод - sequential(). Кроме того, можно также использовать блокирующий метод parallelStream() интерфейса Collection для создания параллельного потока из коллекции. В то же время если рабочая машина не является многоядерной, то поток будет выполняться как последовательный.
Работает на фреймворке fork/join.

Что такое IntStream и DoubleStream?
В Java 8 создание Stream-ов примитивов напрямую невозможно, из-за дженериков. Но разработчики сделали 3 Stream-а примитивов : IntStream, LongStream, DoubleStream. Работает быстрее, чем стрим с классами-обертками. Поддерживают дополнительные терминальный методы sum(), average(), mapToObj()

Java 8
Какие нововведения появились в java 8?
1.	Полноценная поддержка лямбда-вражений
2.	Ссылки на методы ::
3.	Функциональные интерфейсы
4.	default методы в интефейсах
5.	Потоки для работы с коллекциями
6.	Новое api для работы с датами
7.	Nashorn движок JavaScript, разрабатываемый полностью на Java компанией Oracle.
8.	Кодировщик/декодировщик.
9.	Новые методы для Map - PutIfAbsent(), СomputeIfAbsent()\СomputeIfPresent(), Remove(), GetOrDefault(), Merge()
10.	Metaspace пришла на замену PermGen
 
Какие новые классы для работы с датами появились в java 8?
LocalDate , LocalTime, LocalDateTime, ZonedDateTime, Period, Duration

Расскажите про класс Optional
Optional - новый класс в пакете java.util, является контейнером (оберткой) для значений которая также может безопасно содержать null. Благодаря опциональным типам можно забыть про проверки на null и NullPointerException.

Что такое Nashorn?
В Java 8, Nashorn, представлен значительно улучшенный движок javascript для замены существующего Rhino. Nashorn обеспечивает в 2-10 раз лучшую производительность, так как он напрямую компилирует код в памяти и передает байт-код в JVM. Nashorn использует функцию динамического вызова, представленную в Java 7, для повышения производительности.
* Nashorn — немецкое слово (Носорог)

Что такое jjs?
Инструмент командной строки для выполнения JavaScript-кодов на консоли. Какой класс появился в Java 8 для кодирования/декодирования данных? public static class Base64.Encoder /public static class Base64.Decoder

Как создать Base64 кодировщик и декодировщик?
Используя метод getDecoder() класса Base64 он возвращает декодировщик Base64.Decoder, который декодирует данные с помощью схемы кодирования base64.

Какие дополнительные методы для работы с ассоциативными массивами (maps) появились в Java 8?
putIfAbsent() добавляет пару «ключ-значение», только если ключ отсутствовал: map.putIfAbsent("a", "Aa");
forEach() принимает функцию, которая производит операцию над каждым элементом: map.forEach((k, v) -> System.out.println(v));
compute() создаёт или обновляет текущее значение на полученное в результате вычисления (возможно использовать ключ и текущее значение):
map.compute("a", (k, v) -> String.valueOf(k).concat(v)); //["a", "aAa"]
computeIfPresent() если ключ существует, обновляет текущее значение на полученное в результате вычисления (возможно использовать ключ и текущее значение):
map.computeIfPresent("a", (k, v) -> k.concat(v));
computeIfAbsent() если ключ отсутствует, создаёт его со значением, которое вычисляется (возможно использовать ключ):
map.computeIfAbsent("a", k -> "A".concat(k)); //["a","Aa"]
getOrDefault() в случае отсутствия ключа, возвращает переданное значение по-умолчанию: map.getOrDefault("a", "not found");
merge() принимает ключ, значение и функцию, которая объединяет передаваемое и текущее значения. Если под заданным ключем значение отсутствует, то записывает туда передаваемое значение.

-	map.remove(key, value) - Если такое ключ-значение есть в map, то удаляем

Что такое LocalDateTime?
LocalDateTime объединяет вместе LocaleDate и LocalTime, содержит дату и время в календарной системе ISO- 8601 без привязки к часовому поясу. Время хранится с точностью до наносекунды. Содержит множество удобных методов, таких как plusMinutes, plusHours, isAfter, toSecondOfDay и т.д.
Что такое ZonedDateTime?
java.time.ZonedDateTime — аналог java.util.Calendar, класс с самым полным объемом информации о временном контексте в календарной системе ISO-8601. Включает объект ZoneId - временную зону(в ZoneId 599 зон), поэтому все операции с временными сдвигами этот класс проводит с её учётом.
 
Многопоточность
Чем процесс отличается от потока?
Процесс — экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы (например, процессорное время и память). Каждый процесс выполняется в отдельном адресном пространстве: один процесс не может получить доступ к переменным и структурам данных другого.
Если процесс хочет получить доступ к чужим ресурсам, необходимо использовать межпроцессное взаимодействие. Это могут быть конвейеры, файлы, каналы связи между компьютерами и многое другое. Для каждого процесса ОС создает так называемое «виртуальное адресное пространство», к которому процесс имеет прямой доступ. Это пространство принадлежит процессу, содержит только его данные и находится в полном его распоряжении. Операционная система же отвечает за то, как виртуальное пространство процесса проецируется на физическую память.
Поток(thread) — способ выполнения процесса, определяющий последовательность исполнения кода в процессе. Потоки всегда создаются в контексте какого-либо процесса, и вся их жизнь проходит только в его границах.
Потоки могут исполнять один и тот же код и манипулировать одними и теми же данными, а также совместно использовать описатели объектов ядра, поскольку таблица описателей создается не в отдельных потоках, а в процессах. Так как потоки расходуют существенно меньше ресурсов, чем процессы, в процессе выполнения работы выгоднее создавать дополнительные потоки и избегать создания новых процессов.

Чем Thread отличается от Runnable? Когда нужно использовать Thread, а когда Runnable? (Ответ что тред - это класс, а ранбл интерфейс - считается не полным, нужно рассказать подробно)
Thread - это класс, некоторая надстройка над физическим потоком. Runnable - это интерфейс, представляющий абстракцию над выполняемой задачей. Помимо того, что Runnable помогает разрешить проблему множественного наследования, несомненный плюс от его использования состоит в том, что он позволяет логически отделить логику выполнения задачи от непосредственного управления потоком. В классе Thread имеется несколько методов, которые можно переопределить в порожденном классе. Из них обязательному переопределению подлежит только метод run(). Этот же метод, безусловно, должен быть определен и при реализации интерфейса Runnable. Некоторые программисты считают, что создавать подкласс, порожденный от класса Thread, следует только в том случае, если нужно дополнить его новыми функциями. Так, если переопределять любые другие методы из класса Thread не нужно, то можно ограничиться только реализацией интерфейса Runnable. Кроме того, реализация интерфейса Runnable позволяет создаваемому потоку наследовать класс, отличающийся от Thread

Что такое монитор? Как монитор реализован в java?
Монитор - механизм синхронизации потоков, обеспечивающий доступ к неразделяемым ресурсам. Частью монитора является mutex, который встроен в класс Object и имеется у каждого объекта.
Удобно представлять mutex как id захватившего его объекта. Если этот id равен 0 – ресурс свободен. Если не 0 –
ресурс занят. Можно встать в очередь и ждать его освобождения.
В Java монитор реализован с помощью ключевого слова synchronized.

Что такое синхронизация? Какие способы синхронизации существуют в java?
Синхронизация это процесс, который позволяет выполнять потоки параллельно.
В Java все объекты имеют блокировку, благодаря которой только один поток одновременно может получить доступ к критическому коду в объекте. Такая синхронизация помогает предотвратить повреждение состояния объекта.

Способы синхронизации в Java:
Системная синхронизация с использованием wait()/notify().
Поток, который ждет выполнения каких-либо условий, вызывает у этого объекта метод wait(), предварительно захватив его монитор. На этом его работа приостанавливается. Другой поток может вызвать на этом же самом объекте метод notify() (опять же, предварительно захватив монитор объекта), в результате чего, ждущий на объекте поток «просыпается» и продолжает свое выполнение. В обоих случаях монитор надо захватывать в явном виде, через synchronized-блок, потому как методы wait()/notify() не синхронизированы!
 
Системная синхронизация с использованием join().
Метод join(), вызванный у экземпляра класса Thread, позволяет текущему потоку остановиться до того момента, как поток, связанный с этим экземпляром, закончит работу.
Использование классов из пакета java.util.concurrent.Locks - механизмы синхронизации потоков, альтернативы базовым synchronized, wait, notify, notifyAll: Lock, Condition, ReadWriteLock.

Как работают методы wait(), notify() и notifyAll()?
wait(): освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток не вызовет метод notify()/notifyAll();
notify(): продолжает работу потока, у которого ранее был вызван метод wait();
notifyAll(): возобновляет работу всех потоков, у которых ранее был вызван метод wait().
Когда вызван метод wait(), поток освобождает блокировку на объекте и переходит из состояния Работающий (Running) в состояние Ожидания (Waiting). Метод notify() подаёт сигнал одному из потоков, ожидающих на объекте, чтобы перейти в состояние Работоспособный (Runnable). При этом невозможно определить, какой из ожидающих потоков должен стать работоспособным. Метод notifyAll() заставляет все ожидающие потоки для объекта вернуться в состояние Работоспособный (Runnable). Если ни один поток не находится в ожидании на методе wait(), то при вызове notify() или notifyAll() ничего не происходит.
wait(), notify() и notifyAll() должны вызываться только из синхронизированного кода.

В каких состояниях может находиться поток?
New - объект класса Thread создан, но еще не запущен. Он еще не является потоком выполнения и естественно не выполняется.
Runnable - поток готов к выполнению, но планировщик еще не выбрал его.
Running – поток выполняется.
Waiting/blocked/sleeping - поток блокирован или поток ждет окончания работы другого потока.
Dead - поток завершен. Будет выброшено исключение при попытке вызвать метод start() для dead потока.
public enum State (У класса Thread есть внутренний класс State - состояние, а также метод public State getState().)
{
NEW, — поток создан, но еще не запущен; RUNNABLE, — поток выполняется; BLOCKED, — поток блокирован;
WAITING, — поток ждет окончания работы другого потока; TIMED_WAITING, — поток некоторое время ждет окончания другого потока; TERMINATED; — поток завершен.
}

Что такое семафор? Как он реализован в Java?
Semaphore – это новый тип синхронизатора: семафор со счётчиком, реализующий шаблон синхронизации Семафор. Доступ управляется с помощью счётчика: изначальное значение счетчика задается в конструкторе при создании синхронизатора, когда поток заходит в заданный блок кода, то значение счетчика уменьшается на единицу, когда поток его покидает, то увеличивается. Если значение счетчика равно нулю, то текущий поток блокируется, пока кто-нибудь не выйдет из защищаемого блока. Semaphore используется для защиты дорогих ресурсов, которые доступны в ограниченном количестве, например подключение к базе данных в пуле.

Что означает ключевое слово volatile? Почему операции над volatile переменными не атомарны?
Переменная volatile является атомарной для чтения, но операции над переменной НЕ являются атомарными. Поля, для которых неприемлемо увидеть «несвежее» (stale) значение в результате кэширования или переупорядочения.
Если происходит какая-то операция, например, инкримент, то атомарность уже не обеспечивается, потому что сначала выполняется чтение(1), потом изменение(2) в локальной памяти, а затем запись(3). Такая операция не является атомарной и в неё может вклиниться поток по середине.
Атомарная операция выглядит единой и неделимой командой процессора.
Переменная volatile находится в хипе, а не в кэше стека .
 
Для чего нужны Atomic типы данных? Чем отличаются от volatile?
volatile не гарантирует атомарность. Например, операция count++ не станет атомарной просто потому что count объявлена volatile. C другой стороны class AtomicInteger предоставляет атомарный метод для выполнения таких комплексных операций атомарно, например getAndIncrement() – атомарная замена оператора инкремента, его можно использовать, чтобы атомарно увеличить текущее значение на один. Похожим образом сконструированы атомарные версии и для других типов данных.

Что такое потоки демоны? Для чего они нужны? Как создать поток-демон?
Потоки-демоны работают в фоновом режиме вместе с программой, но не являются неотъемлемой частью программы. Если какой-либо процесс может выполняться на фоне работы основных потоков выполнения и его деятельность заключается в обслуживании основных потоков приложения, то такой процесс может быть запущен как поток-демон с помощью метода setDaemon(boolean value), вызванного у потока до его запуска.
Метод boolean isDaemon() позволяет определить, является ли указанный поток демоном или нет. Основной поток приложения может завершить выполнение потока-демона (в отличие от обычных потоков) с окончанием кода метода main(), не обращая внимания, что поток-демон еще работает.
Поток демон можно сделать только если он еще не запущен. Пример демона - GC.

Что такое приоритет потока? На что он влияет? Какой приоритет у потоков по умолчанию?
Приоритеты потоков используются планировщиком потоков для принятия решений о том, когда какому из потоков будет разрешено работать. Теоретически высокоприоритетные потоки получают больше времени процессора, чем низкоприоритетные. Практически объем времени процессора, который получает поток, часто зависит от нескольких факторов помимо его приоритета(является ли поток демоном).
Чтобы установить приоритет потока, используется метод класса Thread: final void setPriority(int level). Значение level изменяется в пределах от Thread.MIN_PRIORITY = 1 до Thread.MAX_PRIORITY = 10. Приоритет по умолчанию - Thread.NORM_PRlORITY = 5.
Получить текущее значение приоритета потока можно вызвав метод: final int getPriority() у экземпляра класса Thread.
Метод yield() можно использовать для того чтобы принудить планировщик выполнить другой поток, который ожидает своей очереди.

Как работает Thread.join()? Для чего он нужен?
Когда поток вызывает join(), он будет ждать пока поток, к которому он присоединяется, будет завершён, либо отработает переданное время:
void join()
void join(long millis) - с временем ожидания void join(long millis, int nanos)
Применение: при распараллелили вычисления, вам надо дождаться результатов, чтобы собрать их в кучу и продолжить выполнение.

Чем отличаются методы wait() и sleep()?
метод sleep() - приостанавливает поток на указанное время. Состояние меняется на WAITING, по истечению -
RUNNABLE.
метод wait() - меняет состояние потока на WAITING. Может быть вызван только у объекта владеющего блокировкой, в противном случае выкинется исключение IllegalMonitorStateException

Можно ли вызвать start() для одного потока дважды?
Нельзя стартовать поток больше, чем единожды. В частности, поток не может быть перезапущен, если он уже завершил выполнение.
Выдает: IllegalThreadStateException

Как правильно остановить поток? Для чего нужны методы .stop(), .interrupt(),
.interrupted(), .isInterrupted().
Как остановить поток?
На данный момент в Java принят уведомительный порядок остановки потока (хотя JDK 1.0 и имеет несколько
 
управляющих выполнением потока методов, например stop(), suspend() и resume() - в следующих версиях JDK все они были помечены как deprecated из-за потенциальных угроз взаимной блокировки).
Для корректной остановки потока можно использовать метод класса Thread - interrupt(). Этот метод выставляет внутренний флаг-статус прерывания. В дальнейшем состояние этого флага можно проверить с помощью метода isInterrupted() или Thread.interrupted() (для текущего потока). Метод interrupt() также способен вывести поток из состояния ожидания или спячки. Т.е. если у потока были вызваны методы sleep() или wait()
– текущее состояние прервется и будет выброшено исключение InterruptedException. Флаг в этом случае не выставляется.
Схема действия при этом получается следующей:
Реализовать поток.
В потоке периодически проводить проверку статуса прерывания через вызов isInterrupted().
Если состояние флага изменилось или было выброшено исключение во время ожидания/спячки, следовательно поток пытаются остановить извне.
Принять решение – продолжить работу (если по каким-то причинам остановиться невозможно) или освободить заблокированные потоком ресурсы и закончить выполнение.
Возможная проблема, которая присутствует в этом подходе – блокировки на потоковом вводе-выводе. Если поток заблокирован на чтении данных - вызов interrupt() из этого состояния его не выведет. Решения тут различаются в зависимости от типа источника данных. Если чтение идет из файла – долговременная блокировка крайне маловероятна и тогда можно просто дождаться выхода из метода read(). Если же чтение каким-то образом связано с сетью – стоит использовать неблокирующий ввод-вывод из Java NIO.
Второй вариант реализации метода остановки (а также и приостановки) – сделать собственный аналог interrupt(). Т.е. объявить в классе потока флаги – на остановку и/или приостановку и выставлять их путем вызова заранее определённых методов извне. Методика действия при этом остаётся прежней – проверять установку флагов и принимать решения при их изменении. Недостатки такого подхода. Во-первых, потоки в состоянии ожидания таким способом не «оживить». Во-вторых, выставление флага одним потоком совсем не означает, что второй поток тут же его увидит. Для увеличения производительности виртуальная машина использует кеш данных потока, в результате чего обновление переменной у второго потока может произойти через неопределенный промежуток времени (хотя допустимым решением будет объявить переменную-флаг как volatile).
Почему не рекомендуется использовать метод Thread.stop()?
При принудительной остановке (приостановке) потока, stop() прерывает поток в недетерменированном месте выполнения, в результате становится совершенно непонятно, что делать с принадлежащими ему ресурсами. Поток может открыть сетевое соединение - что в таком случае делать с данными, которые еще не вычитаны? Где гарантия, что после дальнейшего запуска потока (в случае приостановки) он сможет их дочитать? Если поток блокировал разделяемый ресурс, то как снять эту блокировку и не переведёт ли принудительное снятие к нарушению консистентности системы? То же самое можно расширить и на случай соединения с базой данных: если поток остановят посередине транзакции, то кто ее будет закрывать? Кто и как будет разблокировать ресурсы?
В чем разница между interrupted() и isInterrupted()?
Механизм прерывания работы потока в Java реализован с использованием внутреннего флага, известного как статус прерывания. Прерывание потока вызовом Thread.interrupt() устанавливает этот флаг. Методы Thread.interrupted() и isInterrupted() позволяют проверить, является ли поток прерванным.
Когда прерванный поток проверяет статус прерывания, вызывая статический метод Thread.interrupted(), статус прерывания сбрасывается.
Нестатический метод isInterrupted() используется одним потоком для проверки статуса прерывания у другого потока, не изменяя флаг прерывания.

Чем Runnable отличается от Callable?
Интерфейс Runnable появился в Java 1.0, а интерфейс Callable был введен в Java 5.0 в составе библиотеки java.util.concurrent;
Классы, реализующие интерфейс Runnable для выполнения задачи должны реализовывать метод run(). Классы, реализующие интерфейс Callable - метод call();
Метод Runnable.run() не возвращает никакого значения,
Callable - это параметризованный функциональный интерфейс. Callable.call() возвращает Object, если он не параметризован, иначе указанный тип.
Метод run() НЕ может выбрасывать проверяемые исключения, в то время как метод call() может.
 
Что такое FutureTask?
FutureTask представляет собой отменяемое асинхронное вычисление в параллельном потоке.
Этот класс предоставляет базовую реализацию Future, с методами для запуска и остановки вычисления, методами для запроса состояния вычисления и извлечения результатов. Результат может быть получен только когда вычисление завершено, метод получения будет заблокирован, если вычисление ещё не завершено. Объекты FutureTask могут быть использованы для обёртки объектов Callable и Runnable. Так как FutureTask помимо Future реализует Runnable, его можно передать в Executor на выполнение.

Что такое deadlock?
Взаимная блокировка (deadlock) - явление при котором все потоки находятся в режиме ожидания и своё состояние не меняют. Происходит, когда достигаются состояния:

взаимного исключения: по крайней мере один ресурс занят в режиме неделимости и следовательно только один поток может использовать ресурс в данный момент времени.
удержания и ожидания: поток удерживает как минимум один ресурс и запрашивает дополнительные ресурсы, которые удерживаются другими потоками.
отсутствия предочистки: операционная система не переназначает ресурсы: если они уже заняты, они должны отдаваться удерживающим потокам сразу же.
цикличного ожидания: поток ждет освобождения ресурса другим потоком, который в свою очередь ждёт освобождения ресурса заблокированного первым потоком.

Простейший способ избежать взаимной блокировки – не допускать цикличного ожидания. Этого можно достичь, получая мониторы разделяемых ресурсов в определенном порядке и освобождая их в обратном порядке.

Что такое livelock?
livelock – тип взаимной блокировки, при котором несколько потоков выполняют бесполезную работу, попадая в зацикленность при попытке получения каких-либо ресурсов. При этом их
состояния постоянно изменяются в зависимости друг от друга. Фактической ошибки не возникает, но КПД системы падает до 0. Часто возникает в результате попыток предотвращения deadlock.
Реальный пример livelock, – когда два человека встречаются в узком коридоре и каждый, пытаясь быть вежливым, отходит в сторону, и так они бесконечно двигаются из стороны в сторону, абсолютно не продвигаясь в нужном им направлении.

Что такое race condition?
Состояние гонки (race condition) - ошибка проектирования многопоточной системы или приложения, при которой работа зависит от того, в каком порядке выполняются потоки. Состояние гонки возникает когда поток, который должен исполнится в начале, проиграл гонку и первым исполняется другой
поток: поведение кода изменяется, из-за чего возникают недетерменированные ошибки.
DataRace - это свойство выполнения программы. Согласно JMM, выполнение считается содержащим гонку данных, если оно содержит по крайней мере два конфликтующих доступа (чтение или запись в одну и ту же переменную), которые не упорядочены отношениями «happens before».
Starvation - потоки не заблокированы, но есть нехватка ресурсов из-за чего потоки ничего не делают.

Самый простой способ решения — копирование переменной в локальную переменную. Или просто синхронизация потоков методами и sync-блоками.

Что такое Фреймворк fork/join? Для чего он нужен?
Фреймворк Fork/Join, представленный в JDK 7, - это набор классов и интерфейсов позволяющих использовать преимущества многопроцессорной архитектуры современных компьютеров. Он разработан для выполнения задач, которые можно рекурсивно разбить на маленькие подзадачи, которые можно решать параллельно. Этап Fork: большая задача разделяется на несколько меньших подзадач, которые в свою очередь также разбиваются на меньшие. И так до тех пор, пока задача не становится тривиальной и решаемой последовательным способом.
Этап Join: далее (опционально) идёт процесс «свёртки» - решения подзадач некоторым образом объединяются пока не получится решение всей задачи.
 
Решение всех подзадач (в т.ч. и само разбиение на подзадачи) происходит параллельно.
Для решения некоторых задач этап Join не требуется. Например, для параллельного QuickSort — массив рекурсивно делится на всё меньшие и меньшие диапазоны, пока не вырождается в тривиальный случай из 1 элемента. Хотя в некотором смысле Join будет необходим и тут, т.к. всё равно остаётся необходимость дождаться пока не закончится выполнение всех подзадач.
Ещё одно преимущество этого фреймворка заключается в том, что он использует work-stealing алгоритм: потоки, которые завершили выполнение собственных подзадач, могут
«украсть» подзадачи у других потоков, которые всё ещё заняты.

Что означает ключевое слово synchronized? Где и для чего может использоваться?
Зарезервированное слово позволяет добиваться синхронизации в помеченных им методах или блоках кода

Что является монитором у статического synchronized-метода?
Объект типа Class, соответствующий классу, в котором определен метод.

Что является монитором у нестатического synchronized-метода?
Объект this

util. Concurrent поверхностно.
http://java-online.ru/concurrent.xhtml
Классы и интерфейсы пакета java.util.concurrent объедининены в несколько групп по функциональному признаку:

collections - Набор эффективно работающих в многопоточной среде коллекций. CopyOnWriteArrayList(Set), ConcurrentHashMap.
Итераторы классов данного пакета представляют данные на определенный момент времени. Все операции по изменению коллекции (add, set, remove) приводят к созданию новой копии внутреннего массива. Этим гарантируется, что при проходе итератором по коллекции не будет ConcurrentModificationException.
Отличие ConcurrentHashMap связано с внутренней структурой хранения пар key-value. СoncurrentHashMap использует несколько сегментов, и данный класс нужно рассматривать как группу HashMap’ов. Количество сегментов по умолчанию равно 16. Если пара key-value хранится в 10-ом сегменте, то ConcurrentHashMap заблокирует, при необходимости, только 10-й сегмент, и не будет блокировать остальные 15.
CopyOnWriteArrayList:
-volatile массив внутри
-lock только при модификации списка, поэтому операции чтения очень быстрые
-новая копия массива при модификации
-fail-fast итератор
-модификация через iterator невозможна – UnsupportedOperationException
synchronizers - Объекты синхронизации, позволяющие разработчику управлять и/или ограничивать работу нескольких потоков. Cодержит пять объектов синхронизации: semaphore, countDownLatch, ciclycBarrier, exchanger, phaser.
CountDownLatch - объект синхронизации потоков, блокирующий один или несколько потоков до тех пор, пока не будут выполнены определенные условия. Количество условий задается счетчиком. При обнулении счетчика, т.е. при выполнении всех условий, блокировки выполняемых потоков будут сняты и они продолжат выполнение кода. Одноразовый.
CyclicBarrier — барьерная синхронизация останавливает поток в определенном месте в ожидании прихода остальных потоков группы. Как только все потоки достигнут барьера, барьер снимается и выполнение потоков продолжается. Как и CountDownLatch, использует счетчик и похож на него. Отличие связано с тем, барьер можно использовать повторно(в цикле).
Exchanger — объект синхронизации, используемый для двустороннего обмена данными между двумя потоками. При обмене данными допускается null значения, что позволяет использовать класс для односторонней передачи объекта или же просто, как синхронизатор двух потоков. Обмен данными выполняется вызовом метода exchange, сопровождаемый самоблокировкой потока. Как только второй поток вызовет метод exchange, то синхронизатор Exchanger выполнит обмен данными между потоками.
Phaser — объект синхронизации типа «Барьер», но, в отличие от CyclicBarrier, может иметь несколько барьеров (фаз), и количество участников на каждой фазе может быть разным.
 
atomic - Набор атомарных классов для выполнения атомарных операций. Операция является атомарной, если её можно безопасно выполнять при параллельных вычислениях в нескольких потоках, не используя при этом ни блокировок, ни синхронизацию synchronized.
Queues - содержит классы формирования неблокирующих и блокирующих очередей для многопоточных приложений. Неблокирующие очереди «заточены» на скорость выполнения, блокирующие очереди приостанавливают потоки при работе с очередью.
Locks - Механизмы синхронизации потоков, альтернативы базовым synchronized, wait, notify, notifyAll: Lock, Condition, ReadWriteLock.
Lock — базовый интерфейс, предоставляющий более гибкий подход при ограничении доступа к ресурсам/блокам по сравнению с использованием synchronized. Так, при использовании нескольких блокировок, порядок их освобождения может быть произвольный. Имеется возможность перехода к альтернативному сценарию, если блокировка уже захвачена.

Condition — интерфейсное условие в сочетании с блокировкой Lock позволяет заменить методы монитора/мьютекса (wait, notify и notifyAll) объектом, управляющим ожиданием событий. Объект с условием чаще всего получается из блокировок с использованием метода lock.newCondition(). Таким образом можно получить несколько комплектов wait/notify для одного объекта. Блокировка Lock заменяет использование synchronized, а Condition — объектные методы монитора.

ReadWriteLock — интерфейс создания read/write блокировок, который реализует один единственный класс ReentrantReadWriteLock. Блокировку чтение-запись следует использовать при длительных и частых операциях чтения и редких операциях записи. Тогда при доступе к защищенному ресурсу используются разные методы блокировки, как показано ниже :

ReadWriteLock rwl = new ReentrantReadWriteLock(); Lock readLock = rwl.readLock();
Lock writeLock = rwl.writeLock();
Executors - включает средства, называемые сервисами исполнения, позволяющие управлять потоковыми задачами с возможностью получения результатов через интерфейсы Future и Callable.
ExecutorService служит альтернативой классу Thread, предназначенному для управления потоками. В основу сервиса исполнения положен интерфейс Executor, в котором определен один метод :
void execute(Runnable thread);
При вызове метода execute исполняется поток thread.

Stream API & ForkJoinPool. Как связаны, что это такое.
В Stream API есть простой способ распараллеливания потока метедом parallel() или parallelStream(), чтобы получить выигрыш в производительности на многоядерных машинах.
По-умолчанию parallel stream используют ForkJoinPool.commonPool. Этот пул создается статически и живет пока не будет вызван System::exit. Если задачам не указывать конкретный пул, то они будут исполняться в рамках commonPool.
По-умолчанию, размер пула равен на 1 меньше, чем количество доступных ядер.
Когда некий тред отправляет задачу в common pool, то пул может использовать вызывающий тред (caller-thread) в качестве воркера. ForkJoinPool пытается загрузить своими задачами и вызывающий тред.

Java Memory Model
Описывает как потоки должны взаимнодействовать через общую память. Определяет набор действий межпоточного взаимодействия. В частности, чтение и запись переменной, захват и освобождений монитора, чтение и запись volatile переменной, запуск нового потока.
JMM определяет отношение между этими действиями "happens-before" - абстракцей обозначающей, что если операция X связана отношением happens-before с операцией Y, то весь код следуемый за операцией Y, выполняемый в одном потоке, видит все изменения, сделанные другим потоком, до операции X.
Можно выделить несколько основных областей, имеющих отношение к модели памяти:
Видимость (visibility). Один поток может временно сохранить значения некоторых полей не в основную память, а в регистры или локальный кэш процессора, таким образом второй поток, читая из основной памяти, может не увидеть последних изменений поля. И наоборот, если поток на протяжении какого-то времени работает с регистрами и локальными кэшами, читая данные оттуда, он может сразу не увидеть изменений, сделанных
 
другим потоком в основную память.
К вопросу видимости имеют отношение следующие ключевые слов языка Java: synchronized, volatile, final. С точки зрения Java все переменные (за исключением локальных переменных, объявленных внутри метода) хранятся в heap памяти, которая доступна всем потокам. Кроме этого, каждый поток имеет локальную— рабочую—память, где он хранит копии переменных, с которыми он работает, и при выполнении программы поток работает только с этими копиями.
synchronized - При входе в synchronized метод или блок поток обновляет содержимое локальной памяти, а при выходе из synchronized метода или блока поток записывает изменения, сделанные в локальной памяти, в главную. Такое поведение synchronized методов и блоков следует из правил для отношения «происходит раньше»
volatile - запись volatile-переменных производится в основную память, минуя локальную. и чтение volatile переменной производится также из основной памяти, то есть значение переменной не может сохраняться в регистрах или локальной памяти потока и операция чтения этой переменной гарантированно вернёт последнее записанное в неё значение.
final - после того как объект был корректно создан, любой поток может видеть значения его final полей без дополнительной синхронизации. «Корректно создан» означает, что ссылка на создающийся объект не должна использоваться до тех пор, пока не завершился конструктор объекта.
Рекомендуется изменять final поля объекта только внутри конструктора, в противном случае поведение не специфицировано.
Переупорядочивание (Reordering). Для увеличения производительности процессор/компилятор могут переставлять местами некоторые инструкции/операции. Процессор может решить поменять порядок выполнения операций, если, например, сочтет что такая последовательность выполнится быстрее. Эффект может наблюдаться, когда один поток кладет результаты первой операции в регистр или локальный кэш, а результат второй операции попадает непосредственно в основную память. Тогда второй поток, обращаясь к основной памяти может сначала увидеть результат второй операции, и только потом первой, когда все регистры или кэши синхронизируются с основной памятью.
Также регулируется набором правил «happens-before»: операции чтения и записи volatile переменных не могут быть переупорядочены с операциями чтения и записи других volatile и не-volatile переменных. https://habr.com/ru/company/golovachcourses/blog/221133/

SQL
Что такое DDL? Какие операции в него входят? Рассказать про них.
DDL (Data Definition Language) - операторы определения данных (Data Definition Language, DDL): CREATE создает объект БД (базу, таблицу, представление, пользователя и т. д.),
ALTER изменяет объект, DROP удаляет объект;
TRUNCATE удаляет таблицу и создает её пустую заново, но если в таблице были foreigh key, то создать таблицу не получится. rollback после TRUNCATE невозможен

Что такое DML? Какие операции в него входят? Рассказать про них.
операторы манипуляции данными (Data Manipulation Language, DML): SELECT выбирает данные, удовлетворяющие заданным условиям, INSERT добавляет новые данные,
UPDATE изменяет существующие данные,
DELETE удаляет данные при выполнении условия WHERE;

Что такое TCL? Какие операции в него входят? Рассказать про них.
операторы управления транзакциями (Transaction Control Language, TCL): BEGIN служит для определения начала транзакции
COMMIT применяет транзакцию,
ROLLBACK откатывает все изменения, сделанные в контексте текущей транзакции, SAVEPOINT разбивает транзакцию на более мелкие.

Что такое DCL? Какие операции в него входят? Рассказать про них.
операторы определения доступа к данным (Data Control Language, DCL):
GRANT предоставляет пользователю (группе) разрешения на определенные операции с объектом,
 
REVOKE отзывает ранее выданные разрешения,
DENY задает запрет, имеющий приоритет над разрешением;

Нюансы работы с NULL в SQL. Как проверить поле на NULL?
NULL - специальное значение (псевдозначение), которое может быть записано в поле таблицы базы данных. NULL соответствует понятию «пустое поле», то есть «поле, не содержащее никакого значения».
NULL означает отсутствие, неизвестность информации. Значение NULL не является значением в полном смысле слова: по определению оно означает отсутствие значения и не принадлежит ни одному типу данных. Поэтому NULL не равно ни логическому значению FALSE, ни пустой строке, ни 0. При сравнении NULL с любым значением будет получен результат NULL, а не FALSE и не 0. Более того, NULL не равно NULL! команды: IS NULL, IS NOT NULL

Виды Join’ов?
JOIN - оператор языка SQL, который является реализацией операции соединения реляционной алгебры. Предназначен для обеспечения выборки данных из двух таблиц и включения этих данных в один результирующий набор.

Особенностями операции соединения являются следующее:

-	в схему таблицы-результата входят столбцы обеих исходных таблиц (таблиц-операндов), то есть схема результата является «сцеплением» схем операндов;
-	каждая строка таблицы-результата является «сцеплением» строки из одной таблицы-операнда со строкой второй таблицы-операнда;
-	при необходимости соединения не двух, а нескольких таблиц, операция соединения применяется несколько раз (последовательно).
Какие существуют типы JOIN?
(INNER) JOIN Результатом объединения таблиц являются записи, общие для левой и правой таблиц. Порядок таблиц для оператора не важен, поскольку оператор является симметричным.

LEFT (OUTER) JOIN Кортежи из внутреннего соединения, и не вошедшие во внутреннее соединение кортежи из левого источника. Атрибуты в кортежах, которые не имеют совпадений по общим столбцам заполняются неопределенными значениями. Порядок таблиц для оператора важен, поскольку оператор не является симметричным.

RIGHT (OUTER) JOIN

FULL (OUTER) JOIN Результатом объединения таблиц являются все записи, которые присутствуют в таблицах. Порядок таблиц для оператора не важен, поскольку оператор является симметричным.
CROSS JOIN (декартово произведение) SELECT *
FROM actor
NATURAL JOIN film_actor NATURAL JOIN film

Обратите внимание, в этом запросе нет необходимости указывать какие-либо критерии объединения, поскольку предложение NATURAL JOIN автоматически определяет столбцы, имеющие одинаковые имена в обеих объединяемых таблицах, и помещает их в «скрытое» предложение USING. Если первичные и внешние ключи имеют одинаковые имена, этот подход может показаться полезным, однако это не так.

Что лучше использовать join или подзапросы? Почему?
Обычно лучше использовать JOIN, поскольку в большинстве случаев он более понятен и лучше оптимизируется СУБД (но 100% этого гарантировать нельзя). Так же JOIN имеет заметное преимущество над подзапросами в случае, когда список выбора SELECT содержит столбцы более чем из одной таблицы.
 
Подзапросы лучше использовать в случаях, когда нужно вычислять агрегатные значения и использовать их для сравнений во внешних запросах.

Что делает UNION?
В языке SQL ключевое слово UNION применяется для объединения результатов двух SQL-запросов в единую таблицу, состоящую из схожих записей. Оба запроса должны возвращать одинаковое число столбцов и совместимые типы данных в соответствующих столбцах. Необходимо отметить, что UNION сам по себе не гарантирует порядок записей. Записи из второго запроса могут оказаться в начале, в конце или вообще перемешаться с записями из первого запроса. В случаях, когда требуется определенный порядок, необходимо использовать ORDER BY.
Разница между UNION и UNION ALL заключается в том, что UNION будет пропускать дубликаты записей, тогда как UNION ALL будет включать дубликаты записей.

Чем WHERE отличается от HAVING ( ответа про то что используются в разных частях запроса - недостаточно)?
WHERE нельзя использовать с агрегатными функциями, HAVING можно (предикаты тоже).
В HAVING можно использовать псевдонимы только если они используются для наименования результата агрегатной функции, в WHERE можно всегда. < ?????????
HAVING стоит после GROUP BY, но может использоваться и без него. При отсутствии предложения GROUP BY агрегатные функции применяются ко всему выходному набору строк запроса, т.е. в результате мы получим всего одну строку, если выходной набор не пуст.

Что такое ORDER BY?
ORDER BY упорядочивает вывод запроса согласно значениям в том или ином количестве выбранных столбцов. Многочисленные столбцы упорядочиваются один внутри другого. Возможно определять возрастание ASC или убывание DESC для каждого столбца. По умолчанию установлено - возрастание.

Что такое DISTINCT?
DISTINCT указывает, что для вычислений используются только уникальные значения столбца.

Что такое GROUP BY?
GROUP BY используется для агрегации записей результата по заданным атрибутам. Cоздает отдельную группу для всех возможных значений (включая значение NULL) При использовании GROUP BY все значения NULL считаются равными.

Что такое LIMIT?
Ограничивает выборку заданным числом.

Что такое EXISTS?
EXISTS берет подзапрос, как аргумент, и оценивает его как TRUE, если подзапрос возвращает какие-либо записи и FALSE, если нет.

Расскажите про операторы IN, BETWEEN, LIKE.
•	IN - определяет набор значений.
SELECT * FROM Persons WHERE name IN ('Ivan','Petr','Pavel');
•	BETWEEN определяет диапазон значений. В отличие от IN, BETWEEN чувствителен к порядку, и первое значение в предложении должно быть первым по алфавитному или числовому порядку.
SELECT * FROM Persons WHERE age BETWEEN 20 AND 25;
•	LIKE применим только к полям типа CHAR или VARCHAR, с которыми он используется чтобы находить подстроки. В качестве условия используются символы шаблонизации (wildkards) - специальные символы, которые могут соответствовать чему-нибудь:
_ замещает любой одиночный символ. Например, 'b_t' будет соответствовать словам 'bat' или 'bit', но не будет соответствовать 'brat'.
% замещает последовательность любого числа символов. Например '%p%t' будет соответствовать словам 'put',
 
'posit', или 'opt', но не 'spite'.
SELECT * FROM UNIVERSITY WHERE NAME LIKE '%o';

Что делает оператор MERGE? Какие у него есть ограничения?
MERGE позволяет осуществить слияние данных одной таблицы с данными другой таблицы. При слиянии таблиц проверяется условие, и если оно истинно, то выполняется UPDATE, а если нет - INSERT. При этом изменять поля таблицы в секции UPDATE, по которым идет связывание двух таблиц, нельзя.

MERGE Ships AS t -- таблица, которая будет меняться
USING (SELECT запрос ) AS s ON (t.name = s.ship) -- условие слияния
THEN UPDATE SET t.launched = s.year -- обновление WHEN NOT MATCHED -- если условие не выполняется THEN INSERT VALUES(s.ship, s.year) – вставка

Какие агрегатные функции вы знаете?
Агрегатных функции - функции, которые берут группы значений и сводят их к одиночному значению. Несколько агрегатных функций:
COUNT - производит подсчет записей, удовлетворяющих условию запроса; CONCAT - соединяет строки;
SUM - вычисляет арифметическую сумму всех значений колонки; AVG - вычисляет среднее арифметическое всех значений;
MAX - определяет наибольшее из всех выбранных значений; MIN - определяет наименьшее из всех выбранных значений.

Что такое ограничения (constraints)? Какие вы знаете?
Ограничения - это ключевае слова, которые помогают установить правила размещения данных в базе. Используются при создании БД.

NOT NULL указывает, что значение не может быть пустым.
UNIQUE обеспечивает отсутствие дубликатов.
PRIMARY KEY - комбинация NOT NULL и UNIQUE. Помечает каждую запись в базе данных уникальным значением.
CHECK проверяет вписывается ли значение в заданный диапазон ( s_id int CHECK(s_id > 0) )
FOREIGN KEY создает связь между двумя таблицами и защищает от действий, которые могут нарушить связи между таблицами. FOREIGN KEY в одной таблице указывает на PRIMARY KEY в другой.
DEFAULT устанавливает значение по умолчанию, если значения не предоствлено (name VARCHAR(20) DEFAULT 'noname').

Какие отличия между PRIMARY и UNIQUE?
По умолчанию PRIMARY создает кластерный индекс на столбце, а UNIQUE - некластерный. PRIMARY не разрешает NULL записей, в то время как UNIQUE разрешает одну (а в некоторых СУБД несколько) NULL запись.
Таблица может иметь один PRIMARY KEY и много UNIQUE.

Может ли значение в столбце, на который наложено ограничение FOREIGN KEY, равняться NULL? Может, если на данный столбец не наложено ограничение NOT NULL.

Что такое суррогатные ключи?
Суррога́тный ключ — это дополнительное служебное поле, автоматически добавленное к уже имеющимся информационным полям таблицы, предназначение которого — служить первичным ключом.

Что такое индексы? Какие они бывают?
Индексы относятся к методу настройки производительности, позволяющему быстрее извлекать записи из таблицы. Индекс создает структуру для индексируемого поля. Необходимо просто добавить указатель индекса в таблицу.
 
Есть три типа индексов, а именно:

Уникальный индекс (Unique Index): этот индекс не позволяет полю иметь повторяющиеся значения. Если первичный ключ определен, уникальный индекс применен автоматически.
Кластеризованный индекс (Clustered Index): сортируют и хранят строки данных в таблицах или представлениях на основе их ключевых значений. Это ускоряет операции чтения из БД.
Некластеризованный индекс (Non-Clustered Index): внутри таблицы есть упорядоченный список, содержащий значения ключа некластеризованного индекса и указатель на строку данных, содержащую значение ключа.
Каждый новый индекс увеличивает время, необходимое для создания новых записей из-за упорядочивания. Каждая таблица может иметь много некластеризованных индексов.
Как создать индекс? b3
Индекс можно создать либо с помощью выражения CREATE INDEX:
CREATE INDEX index_name ON table_name (column_name)
либо указав ограничение целостности в виде уникального UNIQUE или первичного PRIMARY ключа в операторе создания таблицы CREATE TABLE.
Имеет ли смысл индексировать данные, имеющие небольшое количество возможных значений?
Примерное правило, которым можно руководствоваться при создании индекса - если объем информации (в байтах) НЕ удовлетворяющей условию выборки меньше, чем размер индекса (в байтах) по данному условию выборки, то в общем случае оптимизация приведет к замедлению выборки.
Когда полное сканирование набора данных выгоднее доступа по индексу?
Полное сканирование производится многоблочным чтением. Сканирование по индексу - одноблочным. Также, при доступе по индексу сначала идет сканирование самого индекса, а затем чтение блоков из набора данных. Число блоков, которые надо при этом прочитать из набора зависит от фактора кластеризации. Если суммарная стоимость всех необходимых одноблочных чтений больше стоимости полного сканирования многоблочным чтением, то полное сканирование выгоднее и оно выбирается оптимизатором.
Таким образом, полное сканирование выбирается при слабой селективности предикатов зароса и/или слабой кластеризации данных, либо в случае очень маленьких наборов данных.

Чем TRUNCATE отличается от DELETE?
DELETE - оператор DML, удаляет записи из таблицы, которые удовлетворяют условиям WHERE. Медленнее, чем TRUNCATE. Есть возможность восстановить данные.
TRUNCATE - DDL оператор, удаляет все строки из таблицы. Нет возможность восстановить данные - сделать ROLLBACK.

Что такое хранимые процедуры? Для чего они нужны?
Хранимая процедура — объект базы данных, представляющий собой набор SQL-инструкций, который хранится на сервере. Хранимые процедуры очень похожи на обыкновенные методы языков высокого уровня, у них могут быть входные и выходные параметры и локальные переменные, в них могут производиться числовые вычисления и операции над символьными данными, результаты которых могут присваиваться переменным и параметрам. В хранимых процедурах могут выполняться стандартные операции с базами данных (как DDL, так и DML). Кроме того, в хранимых процедурах возможны циклы и ветвления, то есть в них могут использоваться инструкции управления процессом исполнения.
Хранимые процедуры позволяют повысить производительность, расширяют возможности программирования и поддерживают функции безопасности данных. В большинстве СУБД при первом запуске хранимой процедуры она компилируется (выполняется синтаксический анализ и генерируется план доступа к данным) и в дальнейшем её обработка осуществляется быстрее.

Что такое представления (VIEW)? Для чего они нужны?
View - виртуальная таблица, представляющая данные одной или более таблиц альтернативным образом.
В действительности представление – всего лишь результат выполнения оператора SELECT, который хранится в структуре памяти, напоминающей SQL таблицу. Они работают в запросах и операторах DML точно также как и основные таблицы, но не содержат никаких собственных данных. Представления значительно расширяют возможности управления данными. Это способ дать публичный доступ к некоторой (но не всей) информации в таблице.
Представления могут основываться как на таблицах, так и на других представлениях, т.е. могут быть вложенными (до 32 уровней вложенности).
 
Что такое временные таблицы? Для чего они нужны?
Подобные таблицы удобны для каких-то временных промежуточных выборок из нескольких таблиц. Создание временной таблицы начинается со знака решетки #. Если используется один знак #, то создается локальная таблица, которая доступна в течение текущей сессии. Ели используются два знака ##, то создается
глобальная временная таблица. В отличие от локальной глобальная временная таблица доступна всем открытым сессиям базы данных.

CREATE TABLE #ProductSummary (ProdId INT IDENTITY,
ProdName NVARCHAR(20),
Price MONEY)

Что такое транзакции? Расскажите про принципы ACID.
ранзакция - это воздействие на базу данных, переводящее её из одного целостного состояния в другое и выражаемое в изменении данных, хранящихся в базе данных.

ACID-принципы транзакций:
•	Атомарность (atomicity) гарантирует, что транзакция будет полностью выполнена или потерпит неудачу, где транзакция представляет одну логическую операцию данных. Это означает, что при сбое одной части любой транзакции происходит сбой всей транзакции и состояние базы данных остается неизменным.
•	Согласованность (consistency). Транзакция, достигающая своего завершения и фиксирующая свои результаты, сохраняет согласованность базы данных
•	Изолированность (isolation). Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на ее результат.
•	Долговечность (durability). Независимо от проблем (к примеру, потеря питания, сбой или ошибки любого рода) изменения, сделанные успешно завершённой транзакцией, должны остаться сохраненными после возвращения системы в работу.

Расскажите про уровни изолированности транзакций.
В порядке увеличения изолированности транзакций и, соответственно, надежности работы с данными:
•	Чтение неподтверждённых данных (read uncommitted) — чтение незафиксированных изменений как своей транзакции, так и параллельных транзакций. Нет гарантии, что данные, измененные другими транзакциями, не будут в любой момент изменены в результате их отката, поэтому такое чтение является потенциальным источником ошибок. Возможны неповторяемое чтение, фантомы и грязное чтение.
•	Чтение подтвержденных данных (read committed) — чтение всех изменений своей транзакции и зафиксированных изменений параллельных транзакций, но процессы-писатели могут изменять уже прочитанные читателем данные. Возможны неповторяемое чтение и фантомы.
•	Повторяемость чтения (repeatable read) — Уровень, позволяющий предотвратить неповторяемое чтение. Т.е. мы не видим в исполняющейся транзакции измененные и удаленные записи этой же или другой транзакцией. Но все еще видим вставленные записи из другой транзакции. В MySQL и PostgreSQL отсутствует эффект чтения фантомов для этого уровня.
•	Упорядочиваемость (serializable) — гарантирует неизменяемость данных другими процессами до завершения транзакции. Проблемы синхронизации не возникают.
https://habr.com/ru/post/469415/ https://www.youtube.com/watch?v=5Z2iFX3OeTo&ab_channel=%D0%A3%D1%80% D0%BE%B8JavaD0%BA%D0%
При параллельном выполнении транзакций возможны следующие проблемы:
Потерянное обновление (lost update) — при одновременном изменении одного блока данных разными транзакциями одно из изменений теряется;
«Грязное» чтение (dirty read) — чтение данных, добавленных или измененных транзакцией, которая впоследствии не подтвердится (откатится);
Неповторяющееся чтение (non-repeatable read) — при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются измененными;
Фантомное чтение (phantom reads) — одна транзакция в ходе своего выполнения несколько раз выбирает множество записей по одним и тем же критериям. Другая транзакция в интервалах между этими выборками добавляет или удаляет записи или изменяет столбцы некоторых записей, используемых в критериях выборки
 
первой транзакции, и успешно заканчивается. В результате получится, что одни и те же выборки в первой транзакции дают разные множества записей.

Что такое нормализация и денормализация? Расскажите про 3 нормальные формы?
Нормализация - это процесс преобразования отношений базы данных к виду, отвечающему нормальным формам (пошаговый, обратимый процесс приведения данных в более простую и логичную структуру).
Целью является уменьшение потенциальной противоречивости хранимой в базе данных информации.

Денормализация базы данных — это процесс обратный от нормализации. Эта техника добавляет избыточные данные в таблицу, учитывая частые запросы к базе данных, которые объединяют данные из разных таблиц в одну таблицу. Необходимо для повышения производительности и скорости извлечения данных, за счет увеличения избыточности данных.

Каждая нормальная форма включает в себя предыдущую. Типы форм:
-	Первая нормальная форма (1NF) - значения всех полей атомарны (неделимы), нет множества значений в одном поле.
-	Вторая нормальная форма (2NF) - все неключевые поля зависят только от ключа целиком, а не от какой-то его части.
-	Третья нормальная форма (3NF) - все неключевые поля не зависят друг от друга.
-	Нормальная форма Бойса-Кодда, усиленная 3 нормальная форма (BCNF) - когда каждая её нетривиальная и неприводимая слева функциональная зависимость имеет в качестве своего детерминанта некоторый потенциальный ключ.
-	Четвёртая нормальная форма (4NF) - не содержатся независимые группы полей, между которыми существует отношение «многие-ко-многим».
-	Пятая нормальная форма (5NF) - каждая нетривиальная зависимость соединения в ней определяется потенциальным ключом (ключами) этого отношения.
-	Доменно-ключевая нормальная форма (DKNF) - каждое наложенное на нее ограничение является логическим следствием ограничений доменов и ограничений ключей, наложенных на данное отношение.
-	Шестая нормальная форма (6NF) - удовлетворяет всем нетривиальным зависимостям соединения, то есть не может быть подвергнута дальнейшей декомпозиции без потерь. Введена как обобщение пятой нормальной формы для хронологической базы данных.

Что такое TIMESTAMP?
DATETIME предназначен для хранения целого числа: YYYYMMDDHHMMSS. И это время не зависит от временной зоны настроенной на сервере. Размер: 8 байт
TIMESTAMP хранит значение равное количеству секунд, прошедших с полуночи 1 января 1970 года по усреднённому времени Гринвича. Тогда была создана Unix. При получении из базы отображается с учётом часового пояса. Размер: 4 байта

Шардирование БД
При большом количестве данных запросы начинают долго выполняться, и сервер начинает не справляться с нагрузкой. Одно из решений, что с этими данными делать — это масштабирование базы данных. Например, шардинг или репликация.
Шардинг бывает вертикальным(партицирование) и горизонтальным.
У нас есть большая таблица, например, с пользователями. Партицирование — это когда мы одну большую таблицу разделяем на много маленьких по какому-либо принципу.
Единственное отличие горизонтального масштабирования от вертикального в том, что горизонтальное будет разносить данные по разным инстансам в других базах.
 
 
Есть таблица news, в которой есть идентификатор, есть категория, в которой эта новость расположена, есть автор новости...
Нужно сделать 2 действия над табличкой — это поставить у нашего шарда, например, news_1, то, что она будет наследоваться от news.
Наследованная таблица будет иметь все колонки родителя, а также она может иметь свои колонки, которые мы дополнительно туда добавим. Там не будет ограничений, индексов и триггеров от родителя — это важно.
2-ое действие — это поставить ограничения. Это будет проверка, что в эту таблицу будут попадать данные только с нужным признаком.
 
Т.е. только записи с category_id=1 будут попадать в эту таблицу.
На базовую таблицу надо добавить правило. Когда мы будем работать с таблицей news, вставка на запись с category_id = 1 должна попасть именно в партицию news_1. Правило называем как хотим.
 

EXPLAIN
Когда вы выполняете какой-нибудь запрос, оптимизатор запросов MySQL пытается придумать оптимальный план выполнения этого запроса. Можно посмотреть этот план используя запрос с ключевым словом EXPLAIN перед оператором SELECT.
EXPLAIN SELECT * FROM categories
После EXPLAIN в запросе вы можете использовать ключевое слово EXTENDED и MySQL покажет вам дополнительную информацию о том, как выполняется запрос. Чтобы увидеть эту информацию, вам нужно сразу после запроса с EXTENDED выполнить запрос SHOW WARNINGS.
EXPLAIN EXTENDED SELECT City.Name FROM City
Затем
SHOW WARNINGS

Как сделать запрос из двух баз?
Если в запросе таблица указывается с именем базы данных database1.table1, то таблица выбирается из database1, если просто table1, то - из активной базы данных.
Надо, чтобы базы были на одном сервере. SELECT t1.*, t2.*
FROM database1.table1 AS t1
INNER JOIN database2.table2 AS t2 ON t1.field1 = t2.field1

Что быстрее убирает дубликаты distinct или group by?
Если нужны уникальные значения - DISTINCT. Если нужно группировать значения - GROUP BY.
 
Если задача заключается именно в поиске дубликатов - GROUP BY будет лучше.

Механизмы оптимизации запросов в БД
Например, добавить индекс по нужной колонке.

Что такое «триггер»?
Триггер (trigger) — это хранимая процедура особого типа, исполнение которой обусловлено действием по модификации данных: добавлением, удалением или изменением данных в заданной таблице реляционной базы данных. Триггер запускается сервером автоматически и все производимые им модификации данных рассматриваются как выполняемые в транзакции, в которой выполнено действие, вызвавшее срабатывание триггера.
Момент запуска триггера определяется с помощью ключевых слов BEFORE (триггер запускается до выполнения связанного с ним события) или AFTER (после события).

Hibernate
Что такое ORM? Что такое JPA? Что такое Hibernate?
ORM(Object Relational Mapping) - это концепция преобразования данных из объектно-ориентированного языка в реляционные БД и наоборот.
JPA(Java Persistence API) - это стандартная для Java спецификация, описывающая принципы ORM. JPA не умеет работать с объектами, а только определяет правила как должен действовать каждый провайдер (Hibernate, EclipseLink), реализующий стандарт JPA
Hibernate - библиотека, являющаяся реализацией этой спецификации, в которой можно использовать стандартные API-интерфейсы JPA.
Важные интерфейсы Hibernate:
Session - обеспечивает физическое соединение между приложением и БД. Основная функция - предлагать DML- операции для экземпляров сущностей.
SessionFactory - это фабрика для объектов Session. Обычно создается во время запуска приложения и сохраняется для последующего использования. Является потокобезопасным объектом и используется всеми потоками приложения.
Transaction - однопоточный короткоживущий объект, используемый для атомарных операций. Это абстракция приложения от основных JDBC транзакций. Session может занимать несколько Transaction в определенных случаях, является необязательным API.
Query - интерфейс позволяет выполнять запросы к БД. Запросы написаны на HQL или на SQL.

Что такое EntityManager?
EntityManager интерфейс JPA, который описывает API для всех основных операций над Entity, а также для получения данных и других сущностей JPA.
Основные операции:
1)	Операции над Entity: persist (добавление Entity), merge (обновление), remove (удаления), refresh (обновление данных), detach (удаление из управление JPA), lock (блокирование Entity от изменений в других thread),
2)	Получение данных: find (поиск и получение Entity), createQuery, createNamedQuery, createNativeQuery, contains, createNamedStoredProcedureQuery, createStoredProcedureQuery
3)	Получение других сущностей JPA: getTransaction, getEntityManagerFactory, getCriteriaBuilder, getMetamodel, getDelegate
4)	Работа с EntityGraph: createEntityGraph, getEntityGraph
5)	Общие операции над EntityManager или всеми Entities: close, clear, isOpen, getProperties, setProperty.
Объекты EntityManager не являются потокобезопасными. Это означает, что каждый поток должен получить свой экземпляр EntityManager, поработать с ним и закрыть его в конце.

Каким условиям должен удовлетворять класс чтобы являться Entity?
Entity это легковесный хранимый объект бизнес логики. Основная программная сущность это entity-класс, который так же может использовать дополнительные классы, которые могут использоваться как вспомогательные классы или для сохранения состояния еntity.
 
1)	Entity класс должен быть помечен аннотацией Entity или описан в XML файле
2)	Entity класс должен содержать public или protected конструктор без аргументов (он также может иметь конструкторы с аргументами) - при получении данных из БД и формировании из них объекта сущности, Hibernate должен создать этот самый объект сущности,
3)	Entity класс должен быть классом верхнего уровня (top-level class),
4)	Entity класс не может быть enum или интерфейсом,
5)	Entity класс не может быть финальным классом (final class),
6)	Entity класс не может содержать финальные поля или методы, если они участвуют в маппинге (persistent final methods or persistent final instance variables),
7)	Если объект Entity класса будет передаваться по значению как отдельный объект (detached object), например через удаленный интерфейс (through a remote interface), он так же должен реализовывать Serializable интерфейс
8)	Поля Entity класс должны быть напрямую доступны только методам самого Entity класса и не должны быть напрямую доступны другим классам, использующим этот Entity. Такие классы должны обращаться только к методам (getter/setter методам или другим методам бизнес-логики в Entity классе),
9)	Entity класс должен содержать первичный ключ, то есть атрибут или группу атрибутов которые уникально определяют запись этого Entity класса в базе данных

Может ли абстрактный класс быть Entity?
Может, при этом он сохраняет все свойства Entity, за исключением того что его нельзя непосредственно инициализировать.

Может ли Entity класс наследоваться от не Entity классов (non-entity classes)?
Может

Может ли Entity класс наследоваться от других Entity классов?
Может

Может ли не Entity класс наследоваться от Entity класса?
Может

Что такое встраиваемый (Embeddable) класс? Какие требования JPA устанавливает к встраиваемым (Embeddable) классам?
Embeddable класс - это класс, который не используется сам по себе, а является частью одного или нескольких Entity-классов. Entity-класс может содержать как одиночные встраиваемые классы, так и коллекции таких классов. Также такие классы могут быть использованы как ключи или значения map. Во время выполнения каждый встраиваемый класс принадлежит только одному объекту Entity-класса и не может быть использован для передачи данных между объектами Entity-классов (то есть такой класс не является общей структурой данных для разных объектов). В целом, такой класс служит для того чтобы выносить определение общих атрибутов для нескольких Entity.
1.	Такие классы должны удовлетворять тем же правилам что Entity классы, за исключением того что они не обязаны содержать первичный ключ и быть отмечены аннотацией Entity
2.	Embeddable класс должен быть помечен аннотацией @Embeddable или описан в XML файле конфигурации JPA. А поле этого класса в Entity аннотацией @Embedded
Embeddable-класс может содержать другой встраиваемый класс.
Встраиваемый класс может содержать связи с другими Entity или коллекциями Entity, если такой класс не используется как первичный ключ или ключ map'ы.

Что такое Mapped Superclass?
Mapped Superclass - это класс, от которого наследуются Entity, он может содержать анотации JPA, однако сам такой класс не является Entity, ему не обязательно выполнять все требования установленные для Entity (например, он может не содержать первичного ключа). Такой класс не может использоваться в операциях EntityManager или Query. Такой класс должен быть отмечен аннотацией MappedSuperclass или описан в xml файле.
Создание такого класса-предка оправдано тем, что мы заранее определяем ряд свойств и методов, которые должны быть определены в сущностях. Использование такого подхода позволило сократить количество кода
 
Какие три типа стратегий наследования мапинга (Inheritance Mapping Strategies) описаны в JPA?
Inheritance Mapping Strategies описывает как JPA будет работать с классами-наследниками Entity:
1)	Одна таблица на всю иерархию классов (SINGLE_TABLE) — все enity, со всеми наследниками записываются в одну таблицу, для идентификации типа entity определяется специальная колонка “discriminator column”. Например, если есть entity Animals c классами-потомками Cats и Dogs, при такой стратегии все entity записываются в таблицу Animals, но при это имеют дополнительную колонку animalType в которую соответственно пишется значение «cat» или «dog». Минусом является то что в общей таблице, будут созданы все поля уникальные для каждого из классов-потомков, которые будет пусты для всех других классов-потомков. Например, в таблице animals окажется и скорость лазанья по дереву от cats и может ли пес приносить тапки от dogs, которые будут всегда иметь null для dog и cat соотвественно.
Нельзя делать констраинт notNull, но можно использовать тригеры.
2)	Стратегия «соединения» (JOINED) — в этой стратегии каждый класс enity сохраняет данные в свою таблицу, но только уникальные поля (не унаследованные от классов-предков) и первичный ключ, а все унаследованные колонки записываются в таблицы класса-предка, дополнительно устанавливается связь (relationships) между этими таблицами, например в случае классов Animals (см.выше), будут три таблицы animals, cats, dogs, причем в cats будет записана только ключ и скорость лазанья, в dogs — ключ и умеет ли пес приносить палку, а в animals все остальные данные cats и dogs c ссылкой на соответствующие таблицы. Минусом тут являются потери производительности от объединения таблиц (join) для любых операций.
3)	Таблица для каждого класса (TABLE_PER_CLASS) — каждый отдельный класс-наследник имеет свою таблицу, т.е. для cats и dogs (см.выше) все данные будут записываться просто в таблицы cats и dogs как если бы они вообще не имели общего суперкласса. Минусом является плохая поддержка полиморфизма (polymorphic relationships) и то что для выборки всех классов иерархии потребуются большое количество отдельных sql запросов или использование UNION запроса.
Для задания стратегии наследования используется аннотация Inheritance (или соответствующие блоки)

Как мапятся Enum'ы?
@Enumerated(EnumType.STRING) - означает, что в базе будут храниться имена Enum.
@Enumerated(EnumType.ORDINAL) - в базе будут храниться порядковые номера Enum.
Другой вариант - мы можем смапить наши enum в БД и обратно в методах с аннотациями @PostLoad и @PrePersist. @EntityListener над классом Entity, в которой указать класс, в котором создать два метода, помеченнх этими аннотациями.
Идея в том, чтобы в сущности иметь не только поле с Enum, но и вспомогательное поле. Поле с Enum аннотируем @Transient, а в БД будет храниться значение из вспомогательного поля.
В JPA с версии 2.1 можно использовать Converter для конвертации Enum’а в некое его значение для сохранения в БД и получения из БД. Все, что нам нужно сделать, это создать новый класс, который реализует javax.persistence.AttributeConverter и аннотировать его с помощью @Converter и поле в сущности аннотацией @Convert.

Как мапятся даты (до java 8 и после)?
Аннотация @Temporal до Java 8, в которой надо было указать какой тип даты мы хотим использовать.
В Java 8 и далее аннотацию ставить не нужно.

Как “смапить” коллекцию примитивов?
@ElementCollection
@OrderBy
Если у нашей сущности есть поле с коллекцией, то мы привыкли ставить над ним аннотации @OneToMany либо @ManyToMany. Но данные аннотации применяются в случае, когда это коллекция других сущностей (entities). Если у нашей сущности коллекция не других сущностей, а базовых или встраиваемых (embeddable) типов для этих случаев в JPA имеется специальная аннотация @ElementCollection, которая указывается в классе сущности над полем коллекции. Все записи коллекции хранятся в отдельной таблице, то есть в итоге получаем две таблицы: одну для сущности, вторую для коллекции элементов.
При добавлении новой строки в коллекцию, она полностью очищается и заполняется заново, так как у элементов нет id. Можно решить с помощью @OrderColumn
@CollectionTable - позволяет редактировать таблицу с коллекцией, прочитать
 
Какие есть виды связей?
Существуют 4 типа связей:
1.	OneToOne - когда один экземпляр Entity может быть связан не больше чем с одним экземпляром другого Entity.
2.	OneToMany - когда один экземпляр Entity может быть связан с несколькими экземплярами других Entity.
3.	ManyToOne - обратная связь для OneToMany. Несколько экземпляров Entity могут быть связаны с одним экземпляром другого Entity.
4.	ManyToMany - экземпляры Entity могут быть связаны с несколькими экземплярами друг друга. Каждую из которых можно разделить ещё на два вида:
1.	Bidirectional с использованием mappedBy на стороне, где указывается @OneToMany
2.	Unidirectional
Bidirectional — ссылка на связь устанавливается у всех Entity, то есть в случае OneToOne A-B в Entity A есть ссылка на Entity B, в Entity B есть ссылка на Entity A. Entity A считается владельцем этой связи (это важно для случаев каскадного удаления данных, тогда при удалении A также будет удалено B, но не наоборот).
Undirectional- ссылка на связь устанавливается только с одной стороны, то есть в случае OneToOne A-B только у Entity A будет ссылка на Entity B, у Entity B ссылки на A не будет.

Что такое владелец связи?
В отношениях между двумя сущностями всегда есть одна владеющая сторона, а владеемой может и не быть, если это однонаправленные отношения.
По сути, у кого есть внешний ключ на другую сущность - тот и владелец связи. То есть, если в таблице одной сущности есть колонка, содержащая внешние ключи от другой сущности, то первая сущность признаётся владельцем связи, вторая сущность - владеемой.
В однонаправленных отношениях сторона, которая имеет поле с типом другой сущности, является владельцем этой связи по умолчанию.

Что такое каскады?
Каскадирование - это когда мы выполняем какое-то действие с целевой Entity, то же самое действие будет применено к связанной Entity.
JPA CascadeType:
ALL - гарантируют, что все персистентные события, которые происходят на родительском объекте, будут переданы дочернему объекту.
PERSIST - означает, что операции save () или persist () каскадно передаются связанным объектам. MERGE - означает, что связанные entity объединяются, когда объединяется entity-владелец.
REMOVE - удаляет все entity, связанные с удаляемой entity.
DETACH - отключает все связанные entity, если происходит «ручное отключение».
REFRESH - повторно считывают значение данного экземпляра и связанных сущностей из базы данных при вызове refresh().

Разница между PERSIST и MERGE?
persist(entity) следует использовать с совершенно новыми объектами, чтобы добавить их в БД (если объект уже существует в БД, будет выброшено исключение EntityExistsException).

Но в случае merge(entity) сущность, которая уже управляется в контексте персистентности, будет заменена новой сущностью (обновленной), и копия этой обновленной сущности вернется обратно. Но рекомендуется использовать для уже сохраненных сущностей.

Какие два типа fetch стратегии в JPA вы знаете?
1)	LAZY — Hibernate может загружать данные не сразу, а при первом обращении к ним, но так как это необязательное требование, то Hibernate имеет право изменить это поведение и загружать их сразу. Это поведение по умолчанию для полей, аннотированных @OneToMany, @ManyToMany и @ElementCollection. В объект загружается прокси lazy-поля.
2)	EAGER — данные поля будут загруженны немедленно. Это поведение по умолчанию для полей, аннотированных @Basic, @ManyToOne и @OneToOne.
 
Какие четыре статуса жизненного цикла Entity объекта (Entity Instance’s Life Cycle) вы можете перечислить?
Transient (New) — свежесозданная оператором new() сущность не имеет связи с базой данных, не имеет данных в базе данных и не имеет сгенерированных первичных ключей.
managed - объект создан, сохранён в бд, имеет primary key, управляется JPA
detached - объект создан, не управляется JPA. В этом состоянии сущность не связана со своим контекстом (отделена от него) и нет экземпляра Session, который бы ей управлял.
removed - объект создан, управляется JPA, будет удален при commit-е и статус станет опять detached

Как влияет операция persist на Entity объекты каждого из четырех статусов?
new → managed, и объект будет сохранен в базу при commit-е транзакции или в результате flush операций managed → операция игнорируется, однако зависимые Entity могут поменять статус на managed, если у них есть аннотации каскадных изменений
detached → exception сразу или на этапе commit-а транзакции
removed → managed, но только в рамках одной транзакции.

Как влияет операция remove на Entity объекты каждого из четырех статусов?
new → операция игнорируется, однако зависимые Entity могут поменять статус на removed, если у них есть аннотации каскадных изменений и они имели статус managed
managed → removed и запись объект в базе данных будет удалена при commit-е транзакции (также произойдут операции remove для всех каскадно зависимых объектов)
detached → exception сразу или на этапе commit-а транзакции
removed → операция игнорируется

Как влияет операция merge на Entity объекты каждого из четырех статусов?
new → будет создан новый managed entity, в который будут скопированы данные прошлого объекта managed → операция игнорируется, однако операция merge сработает на каскадно зависимые Entity, если их статус не managed
detached → либо данные будут скопированы в существующий managed entity с тем же первичным ключом, либо создан новый managed в который скопируются данные
removed → exception сразу или на этапе commit-а транзакции

Как влияет операция refresh на Entity объекты каждого из четырех статусов?
managed → будут восстановлены все изменения из базы данных данного Entity, также произойдет refresh всех каскадно зависимых объектов
new, removed, detached → exception

Как влияет операция detach на Entity объекты каждого из четырех статусов?
managed, removed → detached.
new, detached → операция игнорируется

Для чего нужна аннотация Basic?
@Basic - указывает на простейший тип маппинга данных на колонку таблицы базы данных. Также в параметрах аннотации можно указать fetch стратегию доступа к полю и является ли это поле обязательным или нет. Может быть применена к полю любого из следующих типов:
1.	Примитивы и их обертки.
2.	java.lang.String
3.	java.math.BigInteger
4.	java.math.BigDecimal
5.	java.util.Date
6.	java.util.Calendar
7.	java.sql.Date
8.	java.sql.Time
9.	java.sql.Timestamp
10.	byte[] or Byte[]
 
11.	char[] or Character[]
12.	enums
13.	любые другие типы, которые реализуют Serializable.
Вообще, аннотацию @Basic можно не ставить, как это и происходит по умолчанию. Аннотация @Basic определяет 2 атрибута:

1.	optional - boolean (по умолчанию true) - определяет, может ли значение поля или свойства быть null. Игнорируется для примитивных типов. Но если тип поля не примитивного типа, то при попытке сохранения сущности будет выброшено исключение.

2.	fetch - FetchType (по умолчанию EAGER) - определяет, должен ли этот атрибут извлекаться незамедлительно (EAGER) или лениво (LAZY). Однако, это необязательное требование JPA, и провайдерам разрешено незамедлительно загружать данные, даже для которых установлена ленивая загрузка.

Без аннотации @Basic при получении сущности из БД по умолчанию её поля базового типа загружаются принудительно (EAGER) и значения этих полей могут быть null

Для чего нужна аннотация Column?
@Column сопоставляет поле класса столбцу таблицы, а её атрибуты определяют поведение в этом столбце, используется для генерации схемы базы данных
@Basic vs @Column:
1.	Атрибуты @Basic применяются к сущностям JPA, тогда как атрибуты @Column применяются к столбцам базы данных.
2.	@Basic имеет атрибут optional, который говорит о том, может ли поле объекта быть null или нет; с другой стороны атрибут nullable аннотации @Column указывает, может ли соответствующий столбец в таблице быть null.
3.	Мы можем использовать @Basic, чтобы указать, что поле должно быть загружено лениво.
4.	Аннотация @Column позволяет нам указать имя столбца в таблице и ряд других свойств:
a.	insertable/updatable - можно ли добавлять/изменять данные в колонке, по умолчанию true;
b.	length - длина, для строковых типов данных, по умолчанию 255.
Коротко, в Column (колум) мы задаем constraints (констрейнтс), а в Basic (бейсик) - ФЕТЧ ТАЙП

Для чего нужна аннотация Access?
Она определяет тип доступа (access type) для класса entity, суперкласса, embeddable или отдельных атрибутов, то есть как JPA будет обращаться к атрибутам entity, как к полям класса (FIELD) или как к свойствам класса (PROPERTY), имеющие гетеры (getter) и сетеры (setter).

Определяет тип доступа к полям сущности. Для чтения и записи этих полей есть два подхода:
1.	Field access (доступ по полям). При таком способе аннотации маппинга (Id, Column,...) размещаются над полями, и Hibernate напрямую работает с полями сущности, читая и записывая их.
2.	Property access (доступ по свойствам). При таком способе аннотации размещаются над методами-геттерами, но никак не над сеттерами.\
По умолчанию тип доступа определяется местом, в котором находится аннотация @Id. Если она будет над полем
-	это будет AccessType.FIELD, если над геттером - это AccessType.PROPERTY.
Чтобы явно определить тип доступа у сущности, нужно использовать аннотацию @Access, которая может быть указана у сущности, Mapped Superclass и Embeddable class, а также над полями или методами.
Поля, унаследованные от суперкласса, имеют тип доступа этого суперкласса.
Когда у одной сущности определены разные типы доступа, то нужно использовать аннотацию @Transient для избежания дублирования маппинга.

Для чего нужна аннотация @Cacheable?
@Cacheable - необязательная аннотация JPA, используется для указания того, должна ли сущность храниться в кэше второго уровня. JPA говорит о пяти значениях shared-cache-mode из persistence.xml, который определяет как будет использоваться second-level cache:

❖	ENABLE_SELECTIVE: только сущности с аннотацией @Cacheable (равносильно значению по умолчанию
 
@Cacheable(value=true)) будут сохраняться в кэше второго уровня.
❖	DISABLE_SELECTIVE: все сущности будут сохраняться в кэше второго уровня, за исключением сущностей, помеченных @Cacheable(value=false) как некэшируемые.
❖	ALL: сущности всегда кэшируются, даже если они помечены как некэшируемые.
❖	NONE: ни одна сущность не кэшируется, даже если помечена как кэшируемая. При данной опции имеет смысл вообще отключить кэш второго уровня.
❖	UNSPECIFIED: применяются значения по умолчанию для кэша второго уровня, определенные Hibernate. Это эквивалентно тому, что вообще не используется shared-cache-mode, так как Hibernate не включает кэш второго уровня, если используется режим UNSPECIFIED.

Аннотация @Cacheable размещается над классом сущности. Её действие распространяется на эту сущность и её наследников, если они не определили другое поведение.

Для чего нужна аннотация @Cache?
Это аннотация Hibernate, настраивающая тонкости кэширования объекта в кэше второго уровня Hibernate. @Cache принимает три параметра:
❖	include - имеет по умолчанию значение all и означающий кэширование всего объекта. Второе возможное значение - non-lazy, запрещает кэширование лениво загружаемых объектов. Кэш первого уровня не обращает внимания на эту директиву и всегда кэширует лениво загружаемые объекты.
❖	region - позволяет задать имя региона кэша для хранения сущности. Регион можно представить как разные области кэша, имеющие разные настройки на уровне реализации кэша. Например, можно было бы создать в конфигурации ehcache два региона, один с краткосрочным хранением объектов, другой с долгосрочным и отправлять часто изменяющиеся объекты в первый регион, а все остальные - во второй. Ehcache по умолчанию создает регион для каждой сущности с именем класса этой сущности, соответственно в этом регионе хранятся только эти сущности. К примеру, экземпляры Foo хранятся в Ehcache в кэше с именем “com.baeldung.hibernate.cache.model.Foo”.
❖	usage - задаёт стратегию одновременного доступа к объектам. transactional
read-write
nonstrict-read-write read-only

Для чего нужны аннотации @Embedded и @Embeddable?

@Embeddable - аннотация JPA, размещается над классом для указания того, что класс является встраиваемым в другие классы.
@Embedded - аннотация JPA, используется для размещения над полем в классе-сущности для указания того, что мы внедряем встраиваемый класс.

Как смапить составной ключ?
Составной первичный ключ, также называемый составным ключом, представляет собой комбинацию из двух или более столбцов для формирования первичного ключа таблицы.
@IdClass
Допустим, у нас есть таблица с именем Account, и она имеет два столбца - accountNumber и accountType, которые формируют составной ключ. Чтобы обозначить оба этих поля как части составного ключа мы должны создать класс, например, ComplexKey с этими полями.

Затем нам нужно аннотировать сущность Account аннотацией @IdClass(ComplexKey.class). Мы также должны объявить поля из класса ComplexKey в сущности Account с такими же именами и аннотировать их с помощью @Id.
public class ComplexKey implements Serializable { private String accountNumber;
private String accountType;
// default constructor
public AccountId(String accountNumber, String accountType) { this.accountNumber = accountNumber;
 
this.accountType = accountType;
}
// equals() and hashCode()
}

@Entity @IdClass(ComplexKey.class) public class Account {
@Id
private String accountNumber; @Id
private String accountType;
// other fields, getters and setters
}
@EmbeddedId
Рассмотрим пример, в котором мы должны сохранить некоторую информацию о книге с заголовком и языком в качестве полей первичного ключа. В этом случае класс первичного ключа, BookId, должен быть аннотирован @Embeddable.
Затем нам нужно встроить этот класс в сущность Book, используя @EmbeddedId. @Embeddable
public class BookId implements Serializable { private String title;
private String language;
// default constructor
public BookId(String title, String language) { this.title = title;
this.language = language;
}
// getters, equals() and hashCode() methods
}
@Entity
public class Book { @EmbeddedId
private BookId bookId;
// constructors, other fields, getters and setters
}

Для чего нужна аннотация ID? Какие @GeneratedValue вы знаете?
Аннотация @Id определяет простой (не составной) первичный ключ, состоящий из одного поля. В соответствии с JPA, допустимые типы атрибутов для первичного ключа:
1.	примитивные типы и их обертки;
2.	строки;
3.	BigDecimal и BigInteger;
4.	java.util.Date и java.sql.Date
Если мы хотим, чтобы значение первичного ключа генерировалось для нас автоматически, мы можем добавить первичному ключу, отмеченному аннотацией @Id, аннотацию @GeneratedValue.
Возможно 4 варианта:
AUTO(default) - Указывает, что Hibernate должен выбрать подходящую стратегию для конкретной базы данных, учитывая её диалект, так как у разных БД разные способы по умолчанию. Поведение по умолчанию - исходить из типа поля идентификатора.
IDENTITY - для генерации значения первичного ключа будет использоваться столбец IDENTITY, имеющийся в базе данных. Значения в столбце автоматически увеличиваются вне текущей выполняемой транзакции(на стороне базы, так что этого столбца мы не увидим), что позволяет базе данных генерировать новое значение при каждой операции вставки. В промежутках транзакций сущность будет сохранена.
SEQUENCE - тип генерации, рекомендуемый документацией Hibernate. Для получения значений первичного ключа Hibernate должен использовать имеющиеся в базе данных механизмы генерации последовательных значений (Sequence). В бд можно будет увидеть дополнительную таблицу. Но если наша БД не поддерживает тип
 
SEQUENCE, то Hibernate автоматически переключится на тип TABLE. В промежутках транзакций сущность не будет сохранена, так как хибер возьмет из таблицы id hibernate-sequence и вернётся обратно в приложение.
SEQUENCE - это объект базы данных, который генерирует инкрементные целые числа при каждом последующем запросе.
TABLE - Hibernate должен получать первичные ключи для сущностей из создаваемой для этих целей таблицы, способной содержать именованные сегменты значений для любого количества сущностей. Требует использования пессимистических блокировок, которые помещают все транзакции в последовательный порядок и замедляет работу приложения.

Расскажите про аннотации @JoinColumn и @JoinTable? Где и для чего они используются?
@JoinColumn используется для указания столбца FOREIGN KEY, используемого при установлении связей между сущностями или коллекциями. Мы помним, что только сущность-владелец связи может иметь внешние ключи от другой сущности (владеемой). Однако, мы можем указать @JoinColumn как во владеющей таблице, так и во владеемой, но столбец с внешними ключами всё равно появится во владеющей таблице.
Особенности использования:
❖	@OneToOne: означает, что появится столбец в таблице сущности-владельца связи, который будет содержать внешний ключ, ссылающийся на первичный ключ владеемой сущности.
❖	@OneToMany/@ManyToOne: если не указать на владеемой стороне связи атрибут mappedBy, создается joinTable с ключами обеих таблиц. Но при этом же у владельца создается столбец с внешними ключами. @JoinColumns используется для группировки нескольких аннотаций @JoinColumn, которые используются при установлении связей между сущностями или коллекциями, у которых составной первичный ключ и требуется несколько колонок для указания внешнего ключа.
В каждой аннотации @JoinColumn должны быть указаны элементы name и referencedColumnName. @JoinTable используется для указания связывающей (сводной, третьей) таблицы между двумя другими таблицами.

Для чего нужны аннотации @OrderBy и @OrderColumn, чем они отличаются?
@OrderBy указывает порядок, в соответствии с которым должны располагаться элементы
коллекций сущностей, базовых или встраиваемых типов при их извлечении из БД. Если в кэше есть нужные данные, то сортировки не будет. Так как @OrderBy просто добавляет к sql-запросу Order By, а при получении данных из кэша, обращения к бд нет. Эта аннотация может использоваться с аннотациями @ElementCollection, @OneToMany, @ManyToMany.
При использовании с коллекциями базовых типов, которые имеют аннотацию @ElementCollection, элементы этой коллекции будут отсортированы в натуральном порядке, по значению базовых типов.
Если это коллекция встраиваемых типов (@Embeddable), то используя точку (".") мы можем сослаться на атрибут внутри встроенного атрибута.
Если это коллекция сущностей, то у аннотации @OrderBy можно указать имя поля сущности, по которому сортировать эти самые сущности:
Если мы не укажем у @OrderBy параметр, то сущности будут упорядочены по первичному ключу.
В случае с сущностями доступ к полю по точке не работает. Попытка использовать вложенное свойство, например @OrderBy ("supervisor.name") повлечет Runtime Exceprtion.
@OrderColumn создает в таблице столбец с индексами порядка элементов, который используется для поддержания постоянного порядка в списке, но этот столбец не считается частью состояния сущности или встраиваемого класса.
Hibernate отвечает за поддержание порядка как в базе данных при помощи столбца, так и при получении сущностей и элементов из БД. Hibernate отвечает за обновление порядка при записи в базу данных, чтобы отразить любое добавление, удаление или иное изменение порядка, влияющее на список в таблице. @OrderBy vs @OrderColumn
Порядок, указанный в @OrderBy, применяется только в рантайме при выполнении запроса к БД, То есть в контексте персистентности, в то время как при использовании @OrderColumn, порядок сохраняется в отдельном столбце таблицы и поддерживается при каждой вставке/обновлении/удалении элементов.

Для чего нужна аннотация Transient?
@Transient используется для объявления того, какие поля у сущности, встраиваемого класса или Mapped SuperClass не будут сохранены в базе данных.
 
Persistent fields (постоянные поля) - это поля, значения которых будут по умолчанию сохранены в БД. Ими являются любые не static и не final поля.
Transient fields (временные поля):
❖	static и final поля сущностей;
❖	иные поля, объявленные явно с использованием Java-модификатора transient, либо JPA-аннотации @Transient.

Какие шесть видов блокировок (lock) описаны в спецификации JPA (или какие есть значения у enum LockModeType в JPA)?
В порядке от самого ненадежного и быстрого, до самого надежного и медленного:
1.	NONE — без блокировки.
2.	OPTIMISTIC (синоним READ в JPA 1) — оптимистическая блокировка, которая работает, как описано ниже: если при завершении транзакции кто-то извне изменит поле @Version, то будет сделан RollBack транзакции и будет выброшено OptimisticLockException.
3.	OPTIMISTIC_FORCE_INCREMENT (синоним WRITE в JPA 1) — работает по тому же алгоритму, что и LockModeType.OPTIMISTIC за тем исключением, что после commit значение поле Version принудительно увеличивается на 1. В итоге окончательно после каждого коммита поле увеличится на 2(увеличение, которое можно увидеть в Post-Update + принудительное увеличение).
4.	PESSIMISTIC_READ — данные блокируются в момент чтения и это гарантирует, что никто в ходе выполнения транзакции не сможет их изменить. Остальные транзакции, тем не менее, смогут параллельно читать эти данные. Использование этой блокировки может вызывать долгое ожидание блокировки или даже выкидывание PessimisticLockException.
5.	PESSIMISTIC_WRITE — данные блокируются в момент записи и никто с момента захвата блокировки не может в них писать и не может их читать до окончания транзакции, владеющей блокировкой. Использование этой блокировки может вызывать долгое ожидание блокировки.
6.	PESSIMISTIC_FORCE_INCREMENT — ведёт себя как PESSIMISTIC_WRITE, но в конце транзакции увеличивает значение поля @Version, даже если фактически сущность не изменилась.
Оптимистичное блокирование - подход предполагает, что параллельно выполняющиеся транзакции редко обращаются к одним и тем же данным и позволяет им свободно выполнять любые чтения и обновления данных. Но при окончании транзакции производится проверка, изменились ли данные в ходе выполнения данной транзакции и, если да, транзакция обрывается и выбрасывается OptimisticLockException. Оптимистичное блокирование в JPA реализовано путём внедрения в сущность специального поля версии:
@Version
private long version;
Поле, аннотирование @Version, может быть целочисленным или временнЫм. При завершении транзакции, если сущность была заблокирована оптимистично, будет проверено, не изменилось ли значение @Version кем-либо ещё, после того как данные были прочитаны, и, если изменилось, будет выкинуто OptimisticLockException.
Использование этого поля позволяет отказаться от блокировок на уровне базы данных и сделать всё на уровне JPA, улучшая уровень конкурентности.
Позволяет отказатьсь от блокировок на уровне БД и делать всё с JPA.
Пессимистичное блокирование - подход напротив, ориентирован на транзакции, которые часто конкурируют за одни и те же данные и поэтому блокирует доступ к данным в тот момент когда читает их. Другие транзакции останавливаются, когда пытаются обратиться к заблокированным данным и ждут снятия блокировки (или кидают исключение). Пессимистичное блокирование выполняется на уровне базы и поэтому не требует вмешательств в код сущности.
Блокировки ставятся путём вызова метода lock() у EntityManager, в который передаётся сущность, требующая блокировки и уровень блокировки:
EntityManager em = entityManagerFactory.createEntityManager(); em.lock(company1, LockModeType.OPTIMISTIC);

Какие два вида кэшей (cache) вы знаете в JPA и для чего они нужны?
1.	first-level cache (кэш первого уровня) — кэширует данные одной транзакции;
2.	second-level cache (кэш второго уровня) — кэширует данные транзакций от одной фабрики сессий. Провайдер JPA может, но не обязан реализовывать работу с кэшем второго уровня.
Кэш первого уровня – это кэш сессии (Session), который является обязательным, это и есть PersistenceContext. Через него проходят все запросы.
В том случае, если мы выполняем несколько обновлений объекта, Hibernate старается отсрочить (насколько это
 
возможно) обновление этого объекта для того, чтобы сократить количество выполненных запросов в БД. Например, при пяти истребованиях одного и того же объекта из БД в рамках одного persistence context, запрос в БД будет выполнен один раз, а остальные четыре загрузки будут выполнены из кэша. Если мы закроем сессию, то все объекты, находящиеся в кэше, теряются, а далее – либо сохраняются в БД, либо обновляются.
Особенности кэша первого уровня:
❖	включен по умолчанию, его нельзя отключить;
❖	связан с сессией (контекстом персистентности), то есть разные сессии видят только объекты из своего кэша, и не видят объекты, находящиеся в кэшах других сессий;
❖	при закрытии сессии PersistenceContext очищается - кэшированные объекты, находившиеся в нем, удаляются;
❖	при первом запросе сущности из БД, она загружается в кэш, связанный с этой сессией;
❖	если в рамках этой же сессии мы снова запросим эту же сущность из БД, то она будет загружена из кэша, и никакого второго SQL-запроса в БД сделано не будет;
❖	сущность можно удалить из кэша сессии методом evict(), после чего следующая попытка получить эту же сущность повлечет обращение к базе данных;
❖	метод clear() очищает весь кэш сессии.
Если кэш первого уровня привязан к объекту сессии, то кэш второго уровня привязан к объекту-фабрике сессий (Session Factory object) и, следовательно, кэш второго уровня доступен одновременно в нескольких сессиях или контекстах персистентности. Кэш второго уровня требует некоторой настройки и поэтому не включен по умолчанию. Настройка кэша заключается в конфигурировании реализации кэша и разрешения сущностям быть закэшированными.
Hibernate не реализует сам никакого in-memory сache, а использует существующие реализации кэшей.

Как работать с кешем 2 уровня?
Чтение из кэша второго уровня происходит только в том случае, если нужный объект не был найден в кэше первого уровня.
Hibernate поставляется со встроенной поддержкой стандарта кэширования Java JCache, а также двух популярных библиотек кэширования: Ehcache и Infinispan.
В Hibernate кэширование второго уровня реализовано в виде абстракции, то есть мы должны предоставить любую её реализацию, вот несколько провайдеров: Ehcache, OSCache, SwarmCache, JBoss TreeCache. Для Hibernate требуется только реализация интерфейса org.hibernate.cache.spi.RegionFactory, который инкапсулирует все детали, относящиеся к конкретным провайдерам. По сути, RegionFactory действует как мост между Hibernate и поставщиками кэша. В примерах будем использовать Ehcache. Что нужно сделать: ❖ добавить мавен- зависимость кэш-провайдера нужной версии ❖ включить кэш второго уровня и определить конкретного провайдера hibernate.cache.use_second_level_cache=true hibernate.cache.region.factory_class=org.hibernate.cache.ehcache.EhCacheRegionFactory ❖ установить у нужных сущностей JPA-аннотацию @Cacheable, обозначающую, что сущность нужно кэшировать, и Hibernate-аннотацию @Cache, настраивающую детали кэширования, у которой в качестве параметра указать стратегию параллельного доступа" на "Чтение из кэша второго уровня происходит только в том случае, если нужный объект не был найден в кэше первого уровня. Hibernate поставляется со встроенной поддержкой стандарта кэширования Java JCache, а также двух популярных библиотек кэширования: Ehcache и Infinispan.
Стратегии параллельного доступа к объектам Проблема заключается в том, что кэш второго уровня доступен из нескольких сессий сразу и несколько потоков программы могут одновременно в разных транзакциях работать с одним и тем же объектом. Следовательно надо как-то обеспечивать их одинаковым представлением этого объекта. ❖ READ_ONLY: Используется только для сущностей, которые никогда не изменяются (будет выброшено исключение, если попытаться обновить такую сущность). Очень просто и производительно.
Подходит для некоторых статических данных, которые не меняются. ❖ NONSTRICT_READ_WRITE: Кэш обновляется после совершения транзакции, которая изменила данные в БД и закоммитила их. Таким образом, строгая согласованность не гарантируется, и существует небольшое временное окно между обновлением данных в БД и обновлением тех же данных в кэше, во время которого параллельная транзакция может получить из кэша устаревшие данные. ❖ READ_WRITE: Эта стратегия гарантирует строгую согласованность, которую она достигает, используя «мягкие» блокировки: когда обновляется кэшированная сущность, на нее накладывается мягкая блокировка, которая снимается после коммита транзакции. Все параллельные транзакции, которые пытаются получить доступ к записям в кэше с наложенной мягкой блокировкой, не смогут их прочитать или записать и отправят запрос в БД. Ehcache использует эту стратегию по умолчанию. ❖ TRANSACTIONAL:
 
полноценное разделение транзакций. Каждая сессия и каждая транзакция видят объекты, словно они работали с ними последовательно одна транзакция за другой. Плата за это — блокировки и потеря производительности

Что такое JPQL/HQL и чем он отличается от SQL?
Hibernate Query Language (HQL) и Java Persistence Query Language (JPQL) - оба являются объектно- ориентированными языками запросов, схожими по природе с SQL. JPQL - это подмножество HQL.
JPQL - это язык запросов, практически такой же как SQL, однако, вместо имен и колонок таблиц базы данных, он использует имена классов Entity и их атрибуты. В качестве параметров запросов также используются типы данных атрибутов Entity, а не полей баз данных. В отличии от SQL в JPQL есть автоматический полиморфизм, то есть каждый запрос к Entity возвращает не только объекты этого Entity, но также объекты всех его классов- потомков, независимо от стратегии наследования. В JPA запрос представлен в виде javax.persistence.Query или javax.persistence.TypedQuery, полученных из EntityManager.
В Hibernate HQL-запрос представлен org.hibernate.query.Query, полученный из Session. Если HQL является именованным запросом, то будет использоваться Session#getNamedQuery, в противном случае требуется Session#createQuery.

Что такое Criteria API и для чего он используется?
Начиная с версии 5.2 Hibernate Criteria API объявлен deprecated. Вместо него рекомендуется использовать JPA Criteria API.
JPA Criteria API - это актуальный API, используемый только для выборки(select) сущностей из БД в более объектно-ориентированном стиле.
Основные преимущества JPA Criteria API:
❖	ошибки могут быть обнаружены во время компиляции;
❖	позволяет динамически формировать запросы на этапе выполнения приложения. Основные недостатки:
❖	нет контроля над запросом, сложно отловить ошибку
❖	влияет на производительность, множество классов

Для динамических запросов - фрагменты кода создаются во время выполнения - JPA Criteria API является предпочтительней.
Вот некоторые области применения Criteria API:
Criteria API поддерживает проекцию, которую мы можем использовать для агрегатных функций вроде sum(), min(), max() и т.д.
Criteria API может использовать ProjectionList для извлечения данных только из выбранных колонок.
Criteria API может быть использована для join запросов с помощью соединения нескольких таблиц, используя методы createAlias(), setFetchMode() и setProjection().
Criteria API поддерживает выборку результатов согласно условиям (ограничениям). Для этого используется метод add() с помощью которого добавляются ограничения (Restrictions).
Criteria API позволяет добавлять порядок (сортировку) к результату с помощью метода addOrder().

Расскажите про проблему N+1 Select и путях ее решения.
Проблема N+1 запросов возникает, когда получение данных из БД выполняется за N дополнительных SQL- запросов для извлечения тех же данных, которые могли быть получены при выполнении основного SQL-запроса.
1.	JOIN FETCH
И при FetchType.EAGER и при FetchType.LAZY нам поможет JPQL-запрос с JOIN FETCH. Опцию «FETCH» можно использовать в JOIN (INNER JOIN или LEFT JOIN) для выборки связанных объектов в одном запросе вместо дополнительных запросов для каждого доступа к ленивым полям объекта.
Лучший вариант решения для простых запросов (1-3 уровня вложенности связанных объектов).

select pc
from PostComment pc join fetch pc.post p
2.	EntityGraph
В случаях, когда нам нужно получить по-настоящему много данных, и у нас jpql запрос - лучше всего использовать EntityGraph.
 
3.	@Fetch(FetchMode.SUBSELECT)
Аннотация Hibernate. Можно использовать только с коллекциями. Будет сделан один sql-запрос для получения корневых сущностей и, если в контексте персистентности будет обращение к ленивым полям- коллекциям, то выполнится еще один запрос для получения связанных коллекций:

@Fetch(value = FetchMode.SUBSELECT) private Set<Order> orders = new HashSet<>();
4.	Batch fetching
Это Аннотация Hibernate, в JPA её нет. Указывается над классом сущности или над полем коллекции с ленивой загрузкой. Будет сделан один sql-запрос для получения корневых сущностей и, если в контексте персистентности будет обращение к ленивым полям-коллекциям, то выполнится еще один запрос для получения связанных коллекций. Количество загружаемых сущностей указывается в аннотации.

@BatchSize(size=5)
private Set<Order> orders = new HashSet<>();
5.	HibernateSpecificMapping, SqlResultSetMapping
Для нативных запросов рекомендуется использовать именно их.

Что такое EntityGraph? Как и для чего их использовать?
С помощью Entity Graph можно задать для каждого запроса свою стратегию загрузки данных: LAZY либо EAGER.
Определение графа сущностей
Чтобы определить Entity Graph, мы можем либо использовать аннотации над сущностью, либо мы с JPA API.
5.1.	Определение графа сущностей с аннотациями
Аннотация @ NamedEntityGraph позволяет указывать атрибуты, которые необходимо включить, когда мы хотим загрузить объект и связанные с ним ассоциации. **
нужно сначала определить Entity Graph, который загружает данные

Spring
Что такое инверсия контроля (IoC) и внедрение зависимостей (DI)? Как эти принципы реализованы в Spring?
Inversion of Control - подход, который позволяет конфигурировать и управлять объектами Java с помощью рефлексии. Вместо ручного внедрения зависимостей, фреймворк забирает ответственность за это посредством IoC-контейнера. Контейнер отвечает за управление жизненным циклом объекта: создание объектов, вызов методов инициализации и конфигурирование объектов путём связывания их между собой.
Объекты, создаваемые контейнером, называются beans. Конфигурирование контейнера осуществляется путём внедрения аннотаций, но также, есть возможность, по старинке, загрузить XML-файлы, содержащие определение bean’ов и предоставляющие информацию, необходимую для создания bean’ов.
Dependency Injection — является одним из способов реализации принципа IoC в Spring. Это шаблон проектирования, в котором контейнер передает экземпляры объектов по их типу другим объектам с помощью конструктора или метода класса(setter), что позволяет писать слабосвязный код.

Что такое IoC контейнер?
Inversion of Control - подход, который позволяет конфигурировать и управлять объектами Java с помощью рефлексии. Вместо ручного внедрения зависимостей, фреймворк забирает ответственность за это посредством IoC-контейнера. Контейнер отвечает за управление жизненным циклом объекта: создание объектов, вызов методов инициализации и конфигурирование объектов путём связывания их между собой.
Объекты, создаваемые контейнером, называются beans. Конфигурирование контейнера осуществляется путём внедрения аннотаций, но также, есть возможность, по старинке, загрузить XML-файлы, содержащие определение bean’ов и предоставляющие информацию, необходимую для создания bean’ов.
Dependency Injection — является одним из способов реализации принципа IoC в Spring. Это шаблон проектирования, в котором контейнер передает экземпляры объектов по их типу другим объектам с помощью конструктора или метода класса(setter), что позволяет писать слабосвязный код.
 
Расскажите про ApplicationContext и BeanFactory, чем отличаются? В каких случаях что стоит использовать?
ApplicationContext является наследником BeanFactory и полностью реализует его функционал, добавляя больше специфических enterprise-функций. Может работать с бинами всех скоупов.
BeanFactory - это фактический контейнер, который создает, настраивает и управляет рядом bean-компонентов. Эти бины обычно взаимодействуют друг с другом и, таким образом, имеют зависимости между собой. Эти зависимости отражены в данных конфигурации, используемых BeanFactory. Может работать с бинами singleton и prototype.
BeanFactory обычно используется тогда, когда ресурсы ограничены (мобильные устройства), так как он легче по сравнению с ApplicationContext. Поэтому, если ресурсы не сильно ограничены, то лучше использовать ApplicationContext.
ApplicationContext загружает все бины при запуске, а BeanFactory по требованию.
 

Расскажите про аннотацию @Bean?
Аннотация @Bean используется для указания того, что метод создает, настраивает и инициализирует новый объект, управляемый IoC-контейнером. Такие методы можно использовать как в классах с аннотацией @Configuration, так и в классах с аннотацией @Component(или её наследниках).
Имеет следующие свойства:
destroyMethod, initMethod — варианты переопределения методов инициализации и удаления бина, указав их имена в аннотации.
name — имя бина. По умолчанию именем бина является имя метода.
value — алиас для name()

Расскажите про аннотацию @Component?
@Component - используется для указания класса в качестве компонента spring. Такой класс будет сконфигурирован как spring Bean.

Чем отличаются аннотации @Bean и @Component?
@Bean - ставится над методом и позволяет добавить bean, уже реализованного сторонней библиотекой класса, в контейнер, а @Component используется для указания класса, написанного программистом.

Расскажите про аннотации @Service и @Repository. Чем они отличаются?
@Repository - указывает, что класс используется для работы с поиском, получением и хранением данных. Аннотация может использоваться для реализации шаблона DАО.
@Service - указывает, что класс является сервисом для реализации бизнес-логики.
@Repository, @Service, @Controller и @Configuration являются алиасами @Component, их также называют стереотипными аннотациями.

Задача @Repository заключается в том, чтобы отлавливать определенные исключения персистентности и пробрасывать их как одно непроверенное исключение Spring Framework. Для этого в контекст должен быть добавлен класс PersistenceExceptionTranslationPostProcessor.

Расскажите про аннотацию @Autowired
@Autowired – автоматическое внедрение подходящего бина:
1)	Контейнер определяет тип объекта для внедрения
 
2)	Контейнер ищет соответствующий тип бина в контексте(он же контейнер)
3)	Если есть несколько кандидатов, и один из них помечен как @Primary, то внедряется он
4)	Если используется @Qualifier, то контейнер будет использовать информацию из @Qualifier, чтобы понять, какой компонент внедрять
5)	В противном случае контейнер внедрит бин, основываясь на его имени или ID
6)	Если ни один из способов не сработал, то будет выброшено исключение
Контейнер обрабатывает DI с помощью AutowiredAnnotationBeanPostProcessor. В связи с этим, аннотация не может быть использована ни в одном BeanFactoryPP или BeanPP.
В аннотации есть один параметр required = true/fals - указывает, обязательно ли делать DI. По умолчанию true. Либо можно не выбрасывать исключение, а оставить поле c null, если нужный бин не был найден - false.
При циклической зависимости, когда объекты ссылаются друг на друга, нельзя ставить над конструктором.

Расскажите про аннотацию @Resource
@Resource(аннотация java) пытается получить зависимость: по имени, по типу, затем по описанию (Qualifier). Имя извлекается из имени аннотируемого сеттера или поля, либо берется из параметра name.

@Resource //По умолчанию поиск бина с именем "context"
private ApplicationContext context;

@Resource(name="greetingService") //Поиск бина с именем "greetingService"
public void setGreetingService(GreetingService service) { this.greetingService = service;
}

Разница с @Autowired:
❖	ищет бин сначала по имени, а потом по типу;
❖	не нужна дополнительная аннотация для указания имени конкретного бина;
❖	@Autowired позволяет отметить место вставки бина как необязательное @Autowired(required = false);
❖	при замене Spring Framework на другой фреймворк, менять аннотацию @Resource не нужно.

Расскажите про аннотацию @Inject
@Inject входит в пакет javax.inject и, чтобы её использовать, нужно добавить зависимость:
<dependency>
<groupId>javax.inject</groupId>
<artifactId>javax.inject</artifactId>
<version>1</version>
</dependency>

@Inject (аннотация java) аналог @Autowired (аннотация spring) в первую очередь пытается подключить зависимость по типу, затем по описанию и только потом по имени. В ней нет параметров. Поэтому при использовании конкретного имени (Id) бина используем @Named:

@Inject @Named("yetAnotherFieldInjectDependency")
private ArbitraryDependency yetAnotherFieldInjectDependency;

Расскажите про аннотацию @Lookup
Обычно бины в приложении Spring являтся синглтонами, и для внедрения зависимостей мы используем конструктор или сеттер.
Но бывает и другая ситуация: имеется бин Car – синглтон (singleton bean), и ему требуется каждый раз новый экземпляр бина Passenger. То есть Car – синглтон, а Passenger – так называемый прототипный бин (prototype bean).
Жизненные циклы бинов разные. Бин Car создается контейнером только раз, а бин Passenger создается каждый раз новый – допустим, это происходит каждый раз при вызове какого-то метода бина Car. Вот здесь то и пригодится внедрение бина с помощью Lookup метода.
 
Оно происходит не при инициализации контейнера, а позднее: каждый раз, когда вызывается метод. Суть в том, что вы создаете метод-заглушку в бине Car и помечаете его специальным образом – аннотацией @Lookup.
Этот метод должен возвращать бин Passenger, каждый раз новый. Контейнер Spring под капотом создаст подкласс и переопределит этот метод и будет вам выдавать новый экземпляр бина Passenger при каждом вызове аннотированного метода.
Даже если в вашей заглушке он возвращает null (а так и надо делать, все равно этот метод будет переопределен).

Можно ли вставить бин в статическое поле? Почему?
Spring не позволяет внедрять бины напрямую в статические поля. Это связано с тем, что когда загрузчик классов загружает статические значения, контекст Spring ещё не загружен. Чтобы исправить это, создайте нестатический сеттер-метод с @Autowired:
private static OrderItemService orderItemService; @Autowired
public void setOrderItemService(OrderItemService orderItemService) {
TestDataInit.orderItemService = orderItemService;
}

Расскажите про аннотации @Primary и @Qualifier
@Qualifier применяется если кандидатов для автоматического связывания несколько, она позволяет указать в качестве аргумента имя конкретного бина, который следует внедрить. Она может быть применена к отдельному полю класса, к отдельному аргументу метода или конструктора:
public class AutowiredClass {

@Autowired //к полям класса @Qualifier("main")
private GreetingService greetingService;

@Autowired //к отдельному аргументу конструктора или метода public void prepare(@Qualifier("main") GreetingService greetingService){
/* что-то делаем... */
};
}
Соответственно, у одной из реализации GreetingService должна быть установлена соответствующая аннотация @Qualifier:
@Component @Qualifier("main")
public class GreetingServiceImpl implements GreetingService {
//...
}
@Primary тоже используется, чтобы отдавать предпочтение бину, когда есть несколько бинов одного типа, но в ней нельзя задать имя бина, она определяет значение по умолчанию, в то время как @Qualifier более специфичен. Если присутствуют аннотации @Qualifier и @Primary, то аннотация @Qualifier будет иметь приоритет.

Как заинжектить примитив?
Для этого можно использовать аннотацию @Value. Можно ставить над полем, конструктором, методом. Такие значения можно получать из property файлов, из бинов, и т.п.

@Value("${some.key}")
public String stringWithDefaultValue;

В эту переменную будет внедрена строка, например из property или из view.
Кроме того, для внедрения значений мы можем использовать язык SpEL (Spring Expression Language)
 
Как заинжектить коллекцию?
Если внедряемый объект массив, коллекция, или map с дженериком, то используя аннотацию @Autowired, Spring внедрит все бины подходящие по типу в этот массив(или другую структуру данных). В случае с map ключом будет имя бина.
Используя аннотацию @Qualifier можно настроить тип искомого бина.
Бины могут быть упорядочены, когда они вставляются в списки (не Set или Map) или массивы. Поддерживаются как аннотация @Order, так и интерфейс Ordered.

Расскажите про аннотацию @Conditional
Spring предоставляет возможность на основе вашего алгоритма включить или выключить определение бина или всей конфигурации через @Conditional, в качестве параметра которой указывается класс, реализующий интерфейс Condition, с единственным методом matches(ConditionContext var1, AnnotatedTypeMetadata var2), возвращающий boolean.
Для создания более сложных условий можно использовать классы AnyNestedCondition, AllNestedConditions и NoneNestedConditions.
Аннотация @Conditional указывает, что компонент имеет право на регистрацию в контексте только тогда, когда все условия соответствуют.
Условия проверяются непосредственно перед тем, как должен быть зарегистрирован BeanDefinition компонента, и они могут помешать регистрации данного BeanDefinition. Поэтому нельзя допускать, чтобы при проверке условий мы взаимодействовали с бинами, которых еще не существует, с их BeanDefinition-ами можно.
Для того, чтобы проверить несколько условий, можно передать в @Conditional несколько классов с условиями: @Conditional(HibernateCondition.class, OurConditionClass.class)
Если класс @Configuration помечен как @Conditional, то на все методы @Bean, аннотации @Import и аннотации @ComponentScan, связанные с этим классом, также будут распространяться указанные условия.

Расскажите про аннотацию @Profile
Профили - это ключевая особенность Spring Framework, позволяющая нам относить наши бины к разным профилям (логическим группам), например, dev, test, prod.
Мы можем активировать разные профили в разных средах, чтобы загрузить только те бины, которые нам нужны. Используя аннотацию @Profile, мы относим бин к конкретному профилю. Её можно применять на уровне класса или метода. Аннотация @Profile принимает в качестве аргумента имя одного или нескольких профилей.
Она фактически реализована с помощью гораздо более гибкой аннотации @Conditional. Ее можно ставить на @Configuration и Component классы.

Расскажите про жизненный цикл бина, аннотации @PostConstruct и @PreDestroy()
1)	Парсирование конфигурации и создание BeanDefinition
После выхода четвертой версии спринга, у нас появилось четыре способа конфигурирования контекста:
-Xml конфигурация — ClassPathXmlApplicationContext(“context.xml”)
-Конфигурация через аннотации с указанием пакета для сканирования —
AnnotationConfigApplicationContext(“package.name”)
-Конфигурация через аннотации с указанием класса (или массива классов) помеченного аннотацией @Configuration -AnnotationConfigApplicationContext(JavaConfig.class). Этот способ конфигурации называется — JavaConfig.
-Groovy конфигурация — GenericGroovyApplicationContext(“context.groovy”) Цель первого этапа — это создание всех BeanDefinition.
BeanDefinition — это специальный интерфейс, через который можно получить доступ к метаданным будущего бина. В зависимости от того, какая у вас конфигурация, будет использоваться тот или иной механизм парсирования конфигурации.
Допустим, что наша конфигурация основана на аннотациях. Если заглянуть внутрь AnnotationConfigApplicationContext, то можно увидеть два поля.
private final AnnotatedBeanDefinitionReader reader; private
final ClassPathBeanDefinitionScanner scanner; ClassPathBeanDefinitionScanner сканирует указанный пакет на наличие классов помеченных аннотацией @Component (или её алиаса).
Найденные классы парсируются и для них создаются BeanDefinition. Чтобы было запущено сканирование, в конфигурации должен быть указан пакет для сканирования @ComponentScan({"package.name"}).
 
AnnotatedBeanDefinitionReader работает в несколько этапов.
1.	Первый этап — это регистрация всех @Configuration для дальнейшего парсирования. Если в конфигурации используются Conditional, то будут зарегистрированы только те конфигурации, для которых Condition вернет true.
2.	Второй этап — это регистрация BeanDefinitionRegistryPostProcessor, который при помощи класса ConfigurationClassPostProcessor парсирует JavaConfig и создает BeanDefinition. BeanDefinition – это объект, который хранит в себе информацию о бине.
Сюда входит: из какого класса бин надо создать, scope, установлена ли ленивая инициализация, нужно ли перед данным бином инициализировать другой, init и destroy методы, зависимости.
Все полученные BeanDefinition’ы складываются в HashMap, в которой ключём является имя бина, а объект - сам BeanDefinition.
При старте приложения, в IoC контейнер попадут бины, которые имеют scope Singleton (устанавливается по- умолчанию), остальные же создаются, тогда когда они нужны.
2)	Настройка созданных BeanDefinition
Есть возможность повлиять на бины до их создания, иначе говоря мы имеем доступ к метаданным класса. Для этого существует специальный интерфейс BeanFactoryPostProcessor, реализовав который, мы получаем доступ к созданным BeanDefinition и можем их изменять. В нем один метод.
Метод postProcessBeanFactory принимает параметром ConfigurableListableBeanFactory. Данная фабрика содержит много полезных методов, в том числе getBeanDefinitionNames, через который мы можем получить все BeanDefinitionNames,
а уже потом по конкретному имени получить BeanDefinition для дальнейшей обработки метаданных.
Разберем одну из родных реализаций интерфейса BeanFactoryPostProcessor. Обычно, настройки подключения к базе данных выносятся в отдельный property файл, потом при помощи PropertySourcesPlaceholderConfigurer
они загружаются и делается inject этих значений в нужное поле. Так как inject делается по ключу, то до создания экземпляра бина нужно заменить этот ключ на само значение из property файла.
Эта замена происходит в классе, который реализует интерфейс BeanFactoryPostProcessor. Название этого класса
— PropertySourcesPlaceholderConfigurer. Он должен быть объявлен как static

@Bean
public static PropertySourcesPlaceholderConfigurer configurer() { return new PropertySourcesPlaceholderConfigurer();
}
3)	Создание кастомных FactoryBean
FactoryBean — это generic интерфейс, которому можно делегировать процесс создания бинов типа .
В те времена, когда конфигурация была исключительно в xml, разработчикам был необходим механизм с помощью которого они бы могли управлять процессом создания бинов. Именно для этого и был сделан этот интерфейс.
Создадим фабрику которая будет отвечать за создание всех бинов типа — Color.

public class ColorFactory implements FactoryBean<Color> { @Override
public Color getObject() throws Exception { Random random = new Random();
Color color = new Color(random.nextInt(255), random.nextInt(255), random.nextInt(255)); return color;
}

@Override
public Class<?> getObjectType() { return Color.class;
}

@Override
public boolean isSingleton() { return false;
}
}
 
Теперь создание бина типа Color.class будет делегироваться ColorFactory, у которого при каждом создании нового бина будет вызываться метод getObject.
Для тех кто пользуется JavaConfig, этот интерфейс будет абсолютно бесполезен.
4)	Создание экземпляров бинов
Созданием экземпляров бинов занимается BeanFactory на основе ранее созданных BeanDefinition. Из Map<BeanName, BeanDefinition> получаем Map<BeanName, Bean>
Создание бинов может делегироваться кастомным FactoryBean. О их создании читай выше.
Класс, имплементирующий BeanPostProcessor, обязательно должен быть бином, поэтому мы его помечаем аннотацией @Component.
SCOPE_SINGLETON — инициализация произойдет один раз на этапе поднятия контекста. SCOPE_PROTOTYPE
— инициализация будет выполняться каждый раз по запросу.
Причем во втором случае ваш бин будет проходить через все BeanPostProcessor-ы что может значительно ударить по производительности.

Расскажите про скоупы бинов? Какой скоуп используется по умолчанию? Что изменилось в Spring 5?
Существует 2 области видимости по умолчанию.
Singleton - область видимости по умолчанию. В контейнере будет создан только один бин, и все запросы на него будут возвращать один и тот же бин.
Prototype - приводит к созданию нового бина каждый раз, когда он запрашивается.
Для бинов со scope “prototype” Spring не вызывает метод destroy(), так как не берет на себя контроль полного жизненного цикла этого бина. Spring не хранит такие бины в своём контексте ( контейнере), а отдаёт их клиенту и больше о них не заботится (в отличие от синглтон-бинов).

И 4 области видимости в веб-приложении.
Request - Область видимости — 1 HTTP запрос. На каждый запрос создается новый бин Session - Область видимости — 1 сессия. На каждую сессию создается новый бин Application - Область видимости — жизненный цикл ServletContext
WebSocket - Область видимости — жизненный цикл WebSocket Жизненный цикл web csope полный.

В пятой версии Spring Framework не стало Global session scope. И появились Application и WebSocket

Расскажите про аннотацию @ComponentScan
Первый шаг для описания конфигурации Spring это добавление аннотаций — @Component или наследников. Однако, Spring должен знаеть где искать их. В @ComponentScan вы указываете пакеты, которые должны сканироваться. Можно указать массив строк.
Spring будет искать бины и в их подпакетах.
Мы можем расширить это поведение с помощью includeFilters и excludeFilters параметров в аннотации. Для ComponentScan.Filter доступно пять типов фильтров:
ANNOTATION
 
ASSIGNABLE_TYPE ASPECTJ
REGEX CUSTOM
Нужно для того, что например, имея какой-то ненужный класс в не нашей библиотеке, мы можем создать для него фильтр, чтобы его бин не инициализировался.

Как спринг работает с транзакциями? Расскажите про аннотацию @Transactional.
marcobehler.com/guides/spring-transaction-management-transactional-in-depth
Коротко: Spring создает прокси для всех классов, помеченных @Transactional (либо если любой из методов класса помечен этой аннотацией), что позволяет вводить транзакционную логику до и после вызываемого метода. При вызове такого метода происходит следующее:
-	proxy, который создал Spring, создаёт persistence context (или соединение с базой),
-	открывает в нём транзакцию и сохраняет всё это в контексте нити исполнения (натурально, в ThreadLocal).
-	По мере надобности всё сохранённое достаётся и внедряется в бины.

Таким образом, если в вашем коде есть несколько параллельных нитей, у вас будет и несколько параллельных транзакций, которые будут взаимодействовать друг с другом согласно уровням изоляции.

Что произойдёт, если один метод с @Transactional вызовет другой метод с @Transactional?

Если это происходит в рамках одного сервиса, то второй транзакционный метод будет считаться частью первого, так как вызван у него изнутри, а так как спринг не знает о внутреннем вызове, то не создаст прокси для второго метода.

Что произойдёт, если один метод БЕЗ @Transactional вызовет другой метод с @Transactional?

Так как spring не знает о внутреннем вызове, то не создаст прокси для второго метода.

Будет ли транзакция откачена, если будет брошено исключение, которое указано в контракте метода?

Если в контракте описано это исключение, то она не откатится. Unchecked исключения в транзакционном методе можно ловить, а можно и не ловить. Значения атрибута propagation у аннотации:
MANDATORY — всегда используется существующая транзакция и кидается исключение, если текущей транзакции нет.
SUPPORTS — метод с этим правилом будет использовать текущую транзакцию, если она есть, либо будет исполнятся без транзакции, если её нет.
NOT_SUPPORTED — при входе в метод текущая транзакция, если она есть, будет приостановлена и метод будет выполняться без транзакции.
NEVER — явно запрещает исполнение в контексте транзакции. Если при входе в метод будет существовать транзакция, будет выброшено исключение.
Остальные атрибуты:
rollbackFor = Exception.class - если какой-либо метод выбрасывает указанное исключение, контейнер всегда откатывает текущую транзакцию. По умолчанию отлавливает RuntimeException
noRollbackFor = Exception.class - указание того, что любое исключение, кроме заданных, должно приводить к откату транзакции.
rollbackForClassName и noRollbackForClassName - для задания имен исключений в строковом виде.
readOnly - разрешает только операции чтения.
В свойстве transactionManager хранится ссылка на менеджер транзакций, определенный в конфигурации Spring. timeOut - По умолчанию используется таймаут, установленный по умолчанию для базовой транзакционной системы.
Сообщает менеджеру tx о продолжительности времени, чтобы дождаться простоя tx, прежде чем принять решение об откате не отвечающих транзакций.
isolation - уровень изолированности транзакций

Подробно:
 
Для работы с транзакциями Spring Framework использует AOP-прокси:
Для включения возможности управления транзакциями нужно разместить аннотацию @EnableTransactionManagement у класса конфигурации @Configuration.
Она означает, что классы, помеченные @Transactional, должны быть обернуты аспектом транзакций. Отвечает за регистрацию необходимых компонентов Spring, таких как TransactionInterceptor и советы прокси.
Регистрируемые компоненты помещают перехватчик в стек вызовов при вызове методов @Transactional. Если мы используем Spring Boot и имеем зависимости spring-data-* или spring-tx, то управление транзакциями будет включено по умолчанию.
Пропагейшн работает только если метод вызывает другой метод в другом сервисе. Если метод вызывает другой метод в этом же сервисе, то используется this и вызов проходит мимо прокси. Это ограничение можно обойти при помощи self-injection.
Слой логики(Service) - лучшее место для @Transactional.
Помечая @Transactional класс @Service, то все его методы станут транзакционными. Так, при вызове, например, метода save() произойдет примерно следующее:
1.	Вначале мы имеем:
❖	класс TransactionInterceptor, у которого вызывается метод invoke(...), внутри которого вызывается метод класса-родителя TransactionAspectSupport: invokeWithinTransaction(...), в рамках которого происходит магия транзакций.
❖	TransactionManager: решает, создавать ли новый EntityManager и/или транзакцию.
❖	EntityManager proxy: EntityManager - это интерфейс, и то, что внедряется в бин в слое DAO на самом деле не является реализацией EntityManager.
В это поле внедряется EntityManager proxy, который будет перехватывать обращение к полю EntityManager и делегировать выполнение конкретному EntityManager в рантайме. Обычно EntityManager proxy представлен классом SharedEntityManagerInvocationHandler.
2.	Transaction Interceptor
В TransactionInterceptor отработает код до работы метода save(), в котором будет определено, выполнить ли метод save() в пределах уже существующей транзакции БД или должна стартовать новая отдельная транзакция.
TransactionInterceptor сам не содержит логики по принятию решения, решение начать новую транзакцию, если это нужно, делегируется TransactionManager.
Грубо говоря, на данном этапе наш метод будет обёрнут в try-catch и будет добавлена логика до его вызова и после:
try {
transaction.begin(); // логика до service.save();
transaction.commit(); // логика после
} catch(Exception ex) { transaction.rollback(); throw ex;
}
3.	TransactionManager
Менеджер транзакций должен предоставить ответ на два вопроса:
❖	Должен ли создаться новый EntityManager?
❖	Должна ли стартовать новая транзакция БД?
Решение принимается, основываясь на следующих фактах:
❖	выполняется ли хоть одна транзакция в текущий момент или нет;
❖	атрибута «propagation» в @Transactional.
Если TransactionManager решил создать новую транзакцию, тогда:
❖	Создается новый EntityManager;
❖	EntityManager «привязывается» к текущему потоку (Thread);
❖	«Получается» соединение из пула соединений БД;
❖	Соединение «привязывается» к текущему потоку.
И EntityManager и это соединение привязываются к текущему потоку, используя переменные ThreadLocal.
4.	EntityManager proxy
Когда метод save() слоя Service делает вызов метода save() слоя DAO, внутри которого вызывается, например,
 
entityManager.persist(), то не происходит вызов метода persist() напрямую у EntityManager, записанного в поле класса DAO.
Вместо этого метод вызывает EntityManager proxy, который достает текущий EntityManager для нашего потока, и у него вызывается метод persist().

5.	Отрабатывает DAO-метод save().
6.	TransactionInterceptor
Отработает код после работы метода save(), а именно будет принято решение по коммиту/откату транзакции.

Кроме того, если мы в рамках одного метода сервиса обращаемся не только к методу save(), а к разным методам Service и DAO, то все они буду работать в рамках одной транзакции, которая оборачивает этот метод сервиса.
Вся работа происходит через прокси-объекты разных классов. Представим, что у нас в классе сервиса только один метод с аннотацией @Transactional, а остальные нет.
Если мы вызовем метод с @Transactional, из которого вызовем метод без @Transactional, то оба будут отработаны в рамках прокси и будут обернуты в нашу транзакционную логику.
Однако, если мы вызовем метод без @Transactional, из которого вызовем метод с @Transactional, то они уже не будут работать в рамках прокси и не будут обернуты в нашу транзакционную логику.

Расскажите про аннотации @Controller и @RestController. Чем они отличаются? Как вернуть ответ со своим статусом (например 213)?
@Controller - специальный тип класса, обрабатывает HTTP-запросы и часто используется с аннотацией @RequestMapping.
@RestController ставится на класс-контроллер вместо @Controller. Она указывает, что этот класс оперирует не моделями, а данными. Она состоит из аннотаций @Controller и @ResponseBody. Была введена в Spring 4.0 для упрощения создания RESTful веб-сервисов.

@ResponseBody сообщает контроллеру, что возвращаемый объект автоматически сериализуется (используя Jackson message converter) в json или xml и передается обратно в объект HttpResponse.

ResponseEntity используется для формирования кастомизированного HTTP-ответа с пользовательскими параметрами (заголовки, код статуса и тело ответа). Во всех остальных случаях достаточно использовать @ResponseBody.
Если мы хотим использовать ResponseEntity, то просто должны вернуть его из метода, Spring позаботится обо всем остальном.
return ResponseEntity.status(213);

Что такое ViewResolver?
ViewResolver - распознаватель представлений - это способ работы с представлениями(html-файлы), который поддерживает их распознавание на основе имени, возвращаемого контроллером.
Spring Framework поставляется с большим количеством реализаций ViewResolver. Например, класс UrlBasedViewResolver поддерживает прямое преобразование логических имен в URL. InternalResourceViewResolver — реализация ViewResolver по умолчанию, которая позволяет находить представления, которые возвращает контроллер для последующего перехода к ним. Ищет по заданному пути, префиксу, суффиксу и имени.
Любым реализациям ViewResolver желательно поддерживать интернационализацию, то есть множество языков. Существует также несколько реализаций для интеграции с различными технологиями представлений, такими как FreeMarker (FreeMarkerViewResolver), Velocity (VelocityViewResolver) и JasperReports (JasperReportsViewResolver).

Чем отличаются Model, ModelMap и ModelAndView?
Model - интерфейс, представляет коллекцию пар ключ-значение Map<String, Object>. Содержимое модели используется для отображения данных во View.
Например, если View выводит информацию об объекте Customer, то она может ссылаться к ключам модели, например customerName, customerPhone, и получать значения для этих ключей.
Объекты-значения из модели также могут содержать бизнес-логику.
ModelMap - класс, наследуется от LinkedHashMap, тоже используется для передачи значений для
 
визуализации представления.
Преимущество ModelMap заключается в том, что он дает нам возможность передавать коллекцию значений и обрабатывать эти значения, как если бы они были внутри Map.
ModelAndView - это просто контейнер для ModelMap, объект View и HttpStatus. Это позволяет контроллеру возвращать все значения как одно.
View используется для отображения данных приложения пользователю.
Spring MVC поддерживает несколько поставщиков View(они называются шаблонизаторы) — JSP, JSF, Thymeleaf, и т.п.
Интерфейс View преобразует объекты в обычные сервлеты.

Расскажите про паттерн Front Controller, как он реализован в Spring?
Front controller - обеспечивает единую точку входа для всех входящих запросов. Все запросы обрабатываются одним обработчиком – DispatcherServlet с маппингом “/”. Этот обработчик может выполнить аутентификацию, авторизацию, регистрацию или отслеживание запроса, а затем распределяет их между контроллерами, обрабатывающими разные URL. Это и есть реализация паттерна Front Controller.
Веб-приложение может определять любое количество DispatcherServlet-ов. Каждый из них будет работать в своем собственном пространстве имен, загружая свой собственный дочерний WebApplicationContext с вьюшками, контроллерами и т.д.
❖	Один из контекстов будет корневым, а все остальные контексты будут дочерними.
❖	Все дочерние контексты могут получить доступ к бинам, определенным в корневом контексте, но не наоборот.
❖	Каждый дочерний контекст внутри себя может переопределить бины из корневого контекста. WebApplicationContext расширяет ApplicationContext (создаёт и управляет бинами и т.д.), но помимо этого он имеет дополнительный метод getServletContext(), через который у него есть возможность получать
доступ к ServletContext-у.
ContextLoaderListener создает корневой контекст приложения и будет использоваться всеми дочерними контекстами, созданными всеми DispatcherServlet.

Расскажите про паттерн MVC, как он реализован в Spring?
MVC — это шаблон проектирования, делящий программу на 3 вида компонентов:
Model — модель отвечает за хранение данных.
View — отвечает за вывод данных на фронтенде.
Controller — оперирует моделями и отвечает за обмен данными model с view.
Основная цель следования принципам MVC — отделить реализацию бизнес-логики приложения (модели) от ее визуализации (view).
Spring MVC - это веб-фреймворк, основанный на Servlet API, с использованием двух шаблонов проектирования -
Front controller и MVC.
Spring MVC реализует четкое разделение задач, что позволяет нам легко разрабатывать и тестировать наши приложения. Данные задачи разбиты между разными компонентами: Dispatcher Servlet, Controllers, View Resolvers, Views, Models, ModelAndView, Model and Session Attributes, которые полностью независимы друг от друга, и отвечают только за одно направление. Поэтому MVC дает нам довольно большую гибкость. Он основан на интерфейсах (с предоставленными классами реализации), и мы можем настраивать каждую часть фреймворка с помощью пользовательских интерфейсов.
Основные интерфейсы для обработки запросов:
View. Отвечает за возвращение ответа клиенту в виде текстов и изображений. Используются встраиваемые шаблонизаторы (Thymeleaf, FreeMarker и т.д.), так как у Spring нет родных. Некоторые запросы могут идти прямо во View, не заходя в Model, другие проходят через все слои.
HandlerAdapter. Помогает DispatcherServlet вызвать и выполнить метод для обработки входящего запроса. ContextLoaderListener - слушатель при старте и завершении корневого класса Spring WebApplicationContext. Основным назначением является связывание жизненного цикла ApplicationContext и ServletContext, а также автоматического создания ApplicationContext. Можно использовать этот класс для доступа к бинам из различных контекстов спринг.
Ниже приведена последовательность событий, соответствующая входящему HTTP-запросу:
 
 
❖	После получения HTTP-запроса DispatcherServlet обращается к интерфейсу HandlerMapping, который определяет, какой Контроллер (Controller) должен быть вызван, после чего HandlerAdapter, отправляет запрос в нужный метод Контроллера.
❖	Контроллер принимает запрос и вызывает соответствующий метод. Вызванный метод формирует данные Model и возвращает их в DispatcherServlet вместе с именем View (как правило имя html-файла).
❖	При помощи интерфейса ViewResolver DispatcherServlet определяет, какое View нужно использовать на основании имени, полученного от контроллера.
➢	если это REST-запрос на сырые данные (JSON/XML), то DispatcherServlet сам его отправляет, минуя ViewResolver;
➢	если обычный запрос, то DispatcherServlet отправляет данные Model в виде атрибутов во View -
шаблонизаторы Thymeleaf, FreeMarker и т.д., которые сами отправляют ответ. Как видим, все действия происходят через один DispatcherServlet.
Что такое АОП? Как реализовано в спринге?
Аспектно-ориентированное программирование (АОП) — это парадигма программирования, целью которой является повышение модульности за счет разделения междисциплинарных задач.
Это достигается путем добавления дополнительного поведения к существующему коду без изменения самого кода.
АОП предоставляет возможность реализации сквозной логики в одном месте - т.е. логики, которая применяется к множеству частей приложения - и обеспечения автоматического применения этой логики по всему приложению. Аспект в АОП - это модуль или класс, реализующий сквозную функциональность. Аспект изменяет поведение остального кода, применяя совет в точках соединения, определённых некоторым срезом.
Совет (advice) – дополнительная логика — код, который должен быть вызван из точки соединения.
Точка соединения (join point) — место в выполняемой программе (вызов метода, создание объекта, обращение к переменной), где следует применить совет;
Срез (pointcut) — набор точек соединения.
Подход Spring к АОП заключается в создании "динамических прокси" для целевых объектов и "привязывании" объектов к конфигурированному совету для выполнения сквозной логики.
Есть два варианта создания прокси-класса:
1.	либо он должен наследоваться от оригинального класса (CGLIB) и переопределять его методы, добавляя нужную логику;
2.	либо он должен имплементировать те же самые интерфейсы, что и первый класс (Dynamic Proxy).

В чем разница между Filters, Listeners and Interceptors?
Filter выполняет задачи фильтрации либо по пути запроса к ресурсу, либо по пути ответа от ресурса, либо в обоих направлениях.
Фильтры выполняют фильтрацию в методе doFilter. Каждый фильтр имеет доступ к объекту FilterConfig, из которого он может получить параметры инициализации, и ссылку на ServletContext.
Фильтры настраиваются в дескрипторе развертывания веб-приложения.
При создании цепочки фильтров, веб-сервер решает, какой фильтр вызывать первым, в соответствии с порядком регистрации фильтров.
Когда вызывается метод doFilter(...) первого фильтра, веб-сервер создает объект FilterChain, представляющий
 
цепочку фильтров, и передаёт её в метод.
Зависят от контейнера сервлетов. Могут работать с js, css
preHandle — метод используется для обработки запросов, которые еще не были переданы в метод контроллера. Должен вернуть true для передачи следующему перехватчику или в handler method. False укажет на обработку запроса самим обработчиком и отсутствию необходимости передавать его дальше. Метод имеет возможность выкидывать исключения и пересылать ошибки к представлению.
postHandle — вызывается после handler method, но до обработки DispatcherServlet для передачи представлению. Может использоваться для добавления параметров в объект ModelAndView.
afterCompletion — вызывается после отрисовки представления.
Listener - это класс, имплементирующий интерфейс ServletContextListener с аннотацией @WebListener. Listener ждет когда произойдет указанное событие, затем «перехватывает» событие и запускает собственное событие.
Он инициализируется только один раз при запуске веб-приложения и уничтожается при остановке веб- приложения. Все ServletContextListeners уведомляются об инициализации контекста до инициализации любых фильтров или сервлетов в вебприложении и об уничтожении контекста после того, как все сервлеты и фильтры уничтожены.

Можно ли передать в запросе один и тот же параметр несколько раз? Как?
Да, можно принять все значения, используя массив в методе контроллера:

http://localhost:8080/login?name=Ranga&name=Ravi&name=Sathish public String method(@RequestParam(value="name") String[] names){...}

http://localhost:8080/api/foos?id=1,2,3
public String getFoos(@RequestParam List<String> id){...}

Как работает Spring Security? Как сконфигурировать? Какие интерфейсы используются?
В кратце, основными блоками Spring Security являются:

SecurityContextHolder, чтобы обеспечить доступ к SecurityContext.
SecurityContext, содержит объект Authentication и в случае необходимости информацию системы безопасности, связанную с запросом.
Authentication представляет принципала с точки зрения Spring Security.
GrantedAuthority отражает разрешения выданные доверителю в масштабе всего приложения.
UserDetails предоставляет необходимую информацию для построения объекта Authentication из DAO объектов приложения или других источника данных системы безопасности.
UserDetailsService, чтобы создать UserDetails, когда передано имя пользователя в виде String (или идентификатор сертификата или что-то подобное).

Подробно:
Самым фундаментальным явлется SecurityContextHolder. В нем мы храним информацию о текущем контексте безопасности приложения, который включает в себя подробную информацию о пользователе, работающем с приложением. По умолчанию SecurityContextHolder использует MODE_THREADLOCAL для хранения такой информации, что означает, что контекст безопасности всегда доступен для методов исполняющихся в том же самом потоке, даже если контекст безопасности явно не передается в качестве аргумента этих методов:

SecurityContextHolder.getContext().getAuthentication().getPrincipal(); UserDetails выступает в качестве принципала.
MODE_GLOBAL - все потоки Java-машины используют один контекст безопасности. MODE_INHERITABLETHREADLOCAL - потоки порожденные от одного защищенного потока, наличие аналогичной безопасности.
Интерфейс UserDetailsService - подход к загрузке информации о пользователе в Spring Security. Единственный метод этого интерфейса принимает имя пользователя в виде String и возвращает UserDetails. Он представляет собой принципала, но в расширенном виде и с учетом специфики приложения.
В случае успешной аутентификации, UserDetails используется для создания Authentication объекта, который
 
хранится в SecurityContextHolder.
Ещё одним важным методом Authentication явлется getAuthorities() - предоставляет массив объектов GrantedAuthority(роли).
Credentials - под ними понимаются пароль пользователя, но им может быть и отпечаток пальца, фото сетчатки и т.п.
Процесс аутентификации:
1.	UsernamePasswordAuthenticationFilter получают имя пользователя и пароль и создает экземпляр класса UsernamePasswordAuthenticationToken (экземпляр интерфейса Authentication).
2.	Токен передается экземпляру AuthenticationManager для проверки.
3.	AuthenticationManager возвращает полностью заполненный экземпляр Authentication в случае успешной аутентификации.
4.	Устанавливается контекст безопасности путем вызова SecurityContextHolder.getContext().setAuthentication(...), куда передается вернувшийся экземпляр Authentication.
5.	При успешной аутентификации можно использовать successHandler

Что такое SpringBoot? Какие у него преимущества? Как конфигурируется? Подробно.
Spring Boot - это модуль Spring-а, который предоставляет функцию RAD для среды Spring (Rapid Application Development - Быстрая разработка приложений). Он обеспечивает более простой и быстрый способ настройки и запуска как обычных, так и веб-приложений. Он просматривает наши пути к классам и настроенные нами бины, делает разумные предположения о том, чего нам не хватает, и добавляет эти элементы.

Ключевые особенности и преимущества Spring Boot:
1.	Простота управления зависимостями (spring-boot-starter-* в pom.xml).
Чтобы ускорить процесс управления зависимостями Spring Boot неявно упаковывает необходимые сторонние зависимости для каждого типа приложения на основе Spring и предоставляет их разработчику в виде так называемых starter-пакетов.
Starter-пакеты представляют собой набор удобных дескрипторов зависимостей, которые можно включить в свое приложение. Это позволяет получить универсальное решение для всех технологий, связанных со Spring, избавляя программиста от лишнего поиска необходимых зависимостей, библиотек и решения вопросов, связанных с конфликтом версий различных библиотек.
Например, если вы хотите начать использовать Spring Data JPA для доступа к базе данных, просто включите в свой проект зависимость spring-boot-starter-data-jpa.
Starter-пакеты можно создавать и свои.
2.	Автоматическая конфигурация.
Автоматическая конфигурация включается аннотацией @EnableAutoConfiguration. (входит в состав аннотации @SpringBootApplication)
После выбора необходимых для приложения starter-пакетов Spring Boot попытается автоматически настроить Spring-приложение на основе выбранных jar-зависимостей, доступных в classpath классов, свойств в application.properties и т.п. Например, если добавим springboot-starter-web, то Spring boot автоматически сконфигурирует такие бины как DispatcherServlet, ResourceHandlers, MessageSource итд
Автоматическая конфигурация работает в последнюю очередь, после регистрации пользовательских бинов и всегда отдает им приоритет. Если ваш код уже зарегистрировал бин DataSource — автоконфигурация не будет его переопределять.
3.	Встроенная поддержка сервера приложений/контейнера сервлетов (Tomcat, Jetty).
Каждое Spring Boot web-приложение включает встроенный web-сервер. Не нужно беспокоиться о настройке контейнера сервлетов и развертывания приложения в нем. Теперь приложение может запускаться само как исполняемый .jar-файл с использованием встроенного сервера.
4.	Готовые к работе функции, такие как метрики, проверки работоспособности, security и внешняя конфигурация.
5.	Инструмент CLI (command-line interface) для разработки и тестирования приложения Spring Boot.
6.	Минимизация boilerplate кода (код, который должен быть включен во многих местах практически без изменений), конфигурации XML и аннотаций.
Как происходит автоконфигурация в Spring Boot:
1.	Отмечаем main класс аннотацией @SpringBootApplication (аннотация инкапсулирует в себе: @SpringBootConfiguration, @ComponentScan, @EnableAutoConfiguration), таким образом наличие
 
@SpringBootApplication включает сканирование компонентов, автоконфигурацию и показывает разным компонентам Spring (например, интеграционным тестам), что это Spring Boot приложение.
2.	@EnableAutoConfiguration импортирует класс EnableAutoConfigurationImportSelector. Этот класс не объявляет бины сам, а использует фабрики.
3.	Класс EnableAutoConfigurationImportSelector импортирует ВСЕ (более 150) перечисленные в META- INF/spring.factories конфигурации, чтобы предоставить нужные бины в контекст приложения.
4.	Каждая из этих конфигураций пытается сконфигурировать различные аспекты приложения (web, JPA, AMQP и т.д.), регистрируя нужные бины. Логика при регистрации бинов управляется набором @ConditionalOn* аннотаций.
Можно указать, чтобы бин создавался при наличии класса в classpath (@ConditionalOnClass), наличии существующего бина (@ConditionalOnBean), отсуствии бина (@ConditionalOnMissingBean) и т.п.
Таким образом наличие конфигурации не значит, что бин будет создан и зачастую конфигурация ничего делать и создавать не будет.
5.	Созданный в итоге AnnotationConfigEmbeddedWebApplicationContext ищет в том же DI контейнере фабрику для запуска embedded servlet container.
6.	Servlet container запускается, приложение готово к работе

Расскажите про нововведения Spring 5.
●	Используется JDK 8+ (Optional, CompletableFuture, Time API, java.util.function, default methods)
●	Поддержка Java 9 (Automatic-Module-Name in 5.0, module-info in 6.0+, ASM 6)
●	Поддержка HTTP/2 (TLS, Push), NIO/NIO.2
●	Поддержка Kotlin
●	Реактивность (веб-инфраструктура с реактивным стеком, «Spring WebFlux»)
●	Null-safety аннотации(@Nullable), новая документация
●	Совместимость с Java EE 8 (Servlet 4.0, Bean Validation 2.0, JPA 2.2, JSON Binding API 1.0)
●	Поддержка JUnit 5 + Testing Improvements (conditional and concurrent)
●	Удалена поддержка: Portlet, Velocity, JasperReports, XMLBeans, JDO, Guava

Паттерны
Назовите основные характеристики шаблонов.
Имя - все шаблоны имеют уникальное имя, служащее для их идентификации; Назначение данного шаблона;
Задача, которую шаблон позволяет решить;
Способ решения, предлагаемый в шаблоне для решения задачи в том контексте, где этот шаблон был найден; Участники - сущности, принимающие участие в решении задачи;
Следствия от использования шаблона как результат действий, выполняемых в шаблоне; Реализация - возможный вариант реализации шаблона.

Назовите три основные группы паттернов.
Порождающие - отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов без внесения в программу лишних зависимостей.
Структурные - отвечают за построение удобных в поддержке иерархий классов
Поведенческие - заботятся об эффективной коммуникации между объектами.
Основные - основные строительные блоки, используемые для построения других шаблонов. Например, интерфейс.

Расскажите про паттерн Одиночка (Singleton).
Порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.
Конструктор помечается как private, а для создания нового объекта Singleton использует специальный метод getInstance(). Он либо создаёт объект, либо отдаёт существующий объект, если он уже был создан.

private static Singleton instance;

public static Singleton getInstance() { if (instance == null) {
 
instance = new Singleton();
}
return instance;
}
+: можно не создавать множество объектов для ресурсоемких задач, а пользоваться одним
-	: нарушает принцип единой ответственности, так как его могут использовать множество объектов
Почему считается антипаттерном?
-Нельзя тестировать с помощью mock, но можно использовать powerMock.
-Нарушает принцип единой ответственности
-Нарушает Open/Close принцип, его нельзя расширить
Можно ли его синхронизировать без synchronized у метода?
-Можно сделать его Enum (eager). Это статический final класс с константами. JVM загружает final и static классы на этапе компиляции, а значит несколько потоков не могут создать несколько инстансов.
-C помощью double checked locking (lazy). Synchronized внутри метода: private static volatile Singleton instance;

public static Singleton getInstance() { Singleton localInstance = instance;
if (localInstance == null) {
// first check
synchronized (Singleton.class) { localInstance = instance;
if (localInstance == null) {
// second check
instance = localInstance = new Singleton();
}
}
}
return localInstance;
}

Расскажите про паттерн Строитель (Builder).
Порождающий паттерн, который позволяет создавать сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений одного объекта.
Паттерн предлагает вынести конструирование объекта за пределы его собственного класса, поручив это дело отдельным объектам, называемым строителями.
Процесс конструирования объекта разбить на отдельные шаги (например, построитьСтены, вставитьДвери). Чтобы создать объект, вам нужно поочерёдно вызывать методы строителя. Причём не нужно запускать все шаги, а только те, что нужны для производства объекта определённой конфигурации.
Можно пойти дальше и выделить вызовы методов строителя в отдельный класс, называемый директором. В этом случае директор будет задавать порядок шагов строительства, а строитель — выполнять их.

+: Позволяет использовать один и тот же код для создания различных объектов. Изолирует сложный код сборки объектов от его основной бизнес-логики.
-	: Усложняет код программы из-за введения дополнительных классов.

Расскажите про паттерн Фабричный метод (Factory Method).
Порождающий шаблон проектирования, в котором подклассы имплементируют общий интерфейс с методом для создания объектов. Переопределенный метод в каждом наследнике возвращает нужный вариант объекта.
Объекты всё равно будут создаваться при помощи new, но делать это будет фабричный метод. Таким образом можно переопределить фабричный метод в подклассе, чтобы изменить тип создаваемого продукта.
Чтобы эта система заработала, все возвращаемые объекты должны иметь общий интерфейс. Подклассы смогут производить объекты различных классов, следующих одному и тому же интерфейсу.

+: Выделяет код производства объектов в одно место, упрощая поддержку кода. Реализует принцип
 
открытости/закрытости.
-	: Может привести к созданию больших параллельных иерархий классов, так как для каждого класса продукта надо создать свой подкласс создателя.

Расскажите про паттерн Абстрактная фабрика (Abstract Factory).
Порождающий паттерн проектирования, который представляет собой интерфейс для создания других классов, не привязываясь к конкретным классам создаваемых объектов.
Абстрактная фабрика предлагает выделить общие интерфейсы для отдельных продуктов, составляющих семейства. Так, все вариации кресел получат общий интерфейс Кресло, все диваны реализуют интерфейс Диван и так далее.
Далее вы создаёте абстрактную фабрику — общий интерфейс, который содержит фабричные методы создания всех продуктов семейства (например, создатьКресло, создатьДиван и создатьСтолик). Эти операции должны возвращать абстрактные типы продуктов, представленные интерфейсами, которые мы выделили ранее — Кресла, Диваны и Столики.

+: гарантированно будет создаваться тип одного семейства
-	: Усложняет код программы из-за введения множества дополнительных классов.

Расскажите про паттерн Прототип (Prototype)
Порождающий паттерн проектирования, который позволяет копировать объекты, не вдаваясь в подробности их реализации.
Паттерн поручает создание копий самим копируемым объектам. Он вводит общий интерфейс с методом clone для всех объектов, поддерживающих клонирование. Реализация этого метода в разных классах очень схожа. Метод создаёт новый объект текущего класса и копирует в него значения всех полей собственного объекта.

+: Позволяет клонировать объекты, не привязываясь к их конкретным классам.
-	: Сложно клонировать составные объекты, имеющие ссылки на другие объекты.

Расскажите про паттерн Адаптер (Adapter).
Структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе.
Это объект-переводчик, который трансформирует интерфейс или данные одного объекта в такой вид, чтобы он стал понятен другому объекту.
При этом адаптер оборачивает один из объектов, так что другой объект даже не знает о наличии первого.

+: Отделяет и скрывает от клиента подробности преобразования различных интерфейсов.
-	: Усложняет код программы из-за введения дополнительных классов.

Расскажите про паттерн Декоратор (Decorator).
Структурный паттерн проектирования, который позволяет добавлять объектам новую функциональность, оборачивая их в полезные «обёртки».
Целевой объект помещается в другой объект-обёртку, который запускает базовое поведение обёрнутого объекта, а затем добавляет к результату что-то своё.
Оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы, с каким объектом работать — чистым или обёрнутым. Вы можете использовать несколько разных обёрток одновременно — результат будет иметь объединённое поведение всех обёрток сразу.
Адаптер не менят состояния объекта, а декоратор может менять.

+: Большая гибкость, чем у наследования.
-	: Труднее конфигурировать многократно обёрнутые объекты.

Расскажите про паттерн Заместитель (Proxy).
Структурный паттерн проектирования, который позволяет подставлять вместо реальных объектов специальные объекты-заменители, которые перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.
Заместитель предлагает создать новый класс-дублёр, имеющий тот же интерфейс, что и оригинальный
 
служебный объект. При получении запроса от клиента объект-заместитель сам бы создавал экземпляр служебного объекта, выполняя промежуточную логику, которая выполнялась бы до (или после) вызовов этих же методов в настоящем объекте.

+: Позволяет контролировать сервисный объект незаметно для клиента.
-	: Увеличивает время отклика от сервиса.

Расскажите про паттерн Итератор (Iterator).
Поведенческий паттерн проектирования, который даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления.
Идея состоит в том, чтобы вынести поведение обхода коллекции из самой коллекции в отдельный класс.

Детали: Создается итератор и интерфейс, который возвращает итератор. В классе, в котором надо будет вызывать итератор, имплементируем интерфейс, возвращающий итератор, а сам итератор делаем там нестатическим вложенным классом, так как он нигде использоваться больше не будет.

Расскажите про паттерн Шаблонный метод (Template Method).
Поведенческий паттерн проектирования, который пошагово определяет алгоритм и позволяет наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом.
Паттерн предлагает разбить алгоритм на последовательность шагов, описать эти шаги в отдельных методах и вызывать их в одном шаблонном методе друг за другом. Для описания шагов используется абстрактный класс. Общие шаги можно будет описать прямо в абстрактном класе. Это позволит подклассам переопределять некоторые шаги алгоритма, оставляя без изменений его структуру и остальные шаги, которые для этого подкласса не так важны.

Расскажите про паттерн Цепочка обязанностей (Chain of Responsibility).
Поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков. Каждый обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.
Базируется на том, чтобы превратить каждую проверку в отдельный класс с единственным методом выполнения. Данные запроса, над которым происходит проверка, будут передаваться в метод как аргументы.
Каждый из методов будет иметь ссылку на следующий метод-обработчик, что образует цепь. Таким образом, при получении запроса обработчик сможет не только сам что-то с ним сделать, но и передать обработку следующему объекту в цепочке. Может и не передавать, если проверка в одном из методов не прошла, например.

Какие паттерны используются в Spring Framework?
Singleton - Bean scopes Factory - Bean Factory classes Prototype - Bean scopes
Adapter - Spring Web and Spring MVC
Proxy - Spring Aspect Oriented Programming support Template Method - JdbcTemplate, HibernateTemplate etc Front Controller - Spring MVC DispatcherServlet
DAO - Spring Data Access Object support
Dependency Injection

Какие паттерны используются в Hibernate?
Domain Model – объектная модель предметной области, включающая в себя как поведение так и данные.
Data Mapper – слой мапперов (Mappers), который передает данные между объектами и базой данных, сохраняя их независимыми друг от друга и себя.
Proxy — применяется для ленивой загрузки.
Factory — используется в SessionFactory
 
Шаблоны GRASP: Low Coupling (низкая связанность) и High Cohesion (высокая сплоченность)
Low Coupling - части системы, которые изменяются вместе, должны находиться близко друг к другу.
High Cohesion - если возвести Low Coupling в абсолют, то можно прийти к тому, чтобы разместить всю функциональность в одном единственном классе. В таком случае связей не будет вообще, но что-то тут явно не так, ведь в этот класс попадет совершенно несвязанная между собой бизнес-логика. Принцип High Cohesion говорит следующее: части системы, которые изменяются параллельно, должны иметь как можно меньше зависимостей друг на друга.

Low Coupling и High Cohesion представляют из себя два связанных между собой паттерна, рассматривать которые имеет смысл только вместе. Их суть: система должна состоять из слабо связанных классов, которые содержат связанную бизнес-логику. Соблюдение этих принципов позволяет удобно переиспользовать созданные классы, не теряя понимания о их зоне ответственности.

Расскажите про паттерн Saga
Сага — это механизм, обеспечивающий согласованность данных в микросервисах без применения распределенных транзакций.

Для каждой системной команды, которой надо обновлять данные в нескольких сервисах, создается некоторая сага. Сага представляет из себя некоторый «чек-лист», состоящий из последовательных локальных ACID- транзакций, каждая из которых обновляет данные в одном сервисе. Для обработки сбоев применяется компенсирующая транзакция. Такие транзакции выполняются в случае сбоя на всех сервисах, на которых локальные транзакции выполнились успешно.

Типов транзакций в саге четыре:
Компенсирующая — отменяет изменение, сделанное локальной транзакцией.
Компенсируемая — это транзакция, которую необходимо компенсировать (отменить) в случае, если последующие транзакции завершаются неудачей.
Поворотная — транзакция, опеределяющая успешность всей саги. Если она выполняется успешно, то сага гарантированно дойдет до конца.
Повторяемая — идет после поворотной и гарантированно завершается успехом.

Алгоритмы
Что такое Big O? Как происходит оценка асимптотической сложности алгоритмов?
Big O (O большое / символ Ландау) - математическое обозначение порядка функции для сравнения асимптотического поведения функций.
Асимптотика - характер изменения функции при стремлении ее аргумента к определённой точке.
Любой алгоритм состоит из неделимых операций процессора(шагов), поэтому нужно измерять время в операциях процессора, вместо секунд.
DTIME - количество шагов(операций процессора), необходимых, чтобы алгоритм завершился.
Временная сложность обычно оценивается путём подсчёта числа элементарных операций, осуществляемых алгоритмом. Время исполнения одной такой операции при этом берётся константой, то есть асимптотически оценивается как O(1). Сложность алгоритма состоит из двух факторов: временная сложность и сложность по памяти. Временная сложность - функция, представляющая зависимость количество операций процессора, необходимых, чтобы алгоритм звершился, от размера входных данных. Все неделимые операции языка(операции сравнения, арифметические, логические, инициализации и возврата) считаются выполняемыми за 1 операцию процесора, эта погрешность считается приемлемой. При росте N, слагаемые с меньшей скорость роста всё меньше влияют на значение функции. Поэтому, вне зависимости от констант при слагаемых, слагаемое с большей скорость роста определяет значение функии. Данное слагаемое называют порядком
функции. Пример: Т(N) = 5 * N^2 + 999 * N... Где (5 * N^2) и (9999 * N) являются слагаемыми
функции. Константы(5 и 999) не указываются в рамках нотации Big O, так как не показывают абсолютную сложность алгоритма, так как могут изменяться в зависимости от машины, поэтому сложность равна О(N^2)
 
 
В порядке возрастания сложности:
1.	O(1) - константная, чтение по индексу из массива
2.	O(log(n)) - логарифмическая, бинарный поиск в отсортированном массиве
3.	O(√n) - сублинейная
4.	O(n) - линейная, перебор массива в цикле, два цикла подряд, линейный поиск наименьшего или наибольшего элемента в неотсортированном массиве
5.	O(n*log(n)) - квазилинейная, сортировка слиянием, сортировка кучей
6.	O(n^2) - полиномиальная(квадратичная), вложенный цикл, перебор двумерного массива, сортировка пузырьком, сортировка вставками
7.	O(2^n) - экспоненциальная, алгоритмы разложения на множители целых чисел
8.	O(n!) - факториальная, решение задачи коммивояжёра полным перебором
Алгоритм считается приемлемым, если сложность не превышает O(n*log(n)), иначе говнокод.

Что такое рекурсия? Сравните преимущества и недостатки итеративных и рекурсивных алгоритмов. С примерами.
Рекурсия - способ отображения какого-либо процесса внутри самого этого процесса, то есть ситуация, когда процесс является частью самого себя.
Рекурсия состоит из базового случая и шага рекурсии. Базовый случай представляет собой самую простую задачу, которая решается за одну итерацию, например, if(n == 0) return 1.
В базовом случае обязательно присутствует условие выхода из рекурсии;
Смысл рекурсии в движении от исходной задачи к базовому случаю, пошагово уменьшая размер исходной задачи на каждом шаге рекурсии.
После того, как будет найден базовй случай, срабатывает условие выхода из рекурсии, и стек рекурсивных вызовов разворачивается в обратном порядке, пересчитывая результат исходной задачи, который основан на результате, найденном в базовом случае.
Так работает рекурсивное вычисление факториала:
int factorial(int n) {
if(n == 0) return 1; // базовый случай с условием выхода
else return n * factorial(n - 1); // шаг рекурсии (рекурсивный вызов)
}
Или даже так:
return (n==0) ? 1 : n * factorial(n-1); Рекурсия имеет линейную сложность O(n);
Циклы дают лучшую производительность, чем рекурсивные вызовы, поскольку вызовы методов потребляют больше ресурсов, чем исполнение обычных операторов.
Циклы гарантируют отсутствие переполнения стека, т.к. не требуется выделения доп. памяти.
В случае рекурсии стек вызовов разрастается, и его необходимо просматривать для получения конечного ответа. При использовании головной рекурсии также необходимо принимать во внимание размер стека.
Если уровней вложненности много или изменятся, то предпочительна рекурсия. Если их несколько, то лучше цикл.

Что такое жадные алгоритмы? Приведите пример.
Жадные алгоритмы являются одной из 3х техник создания алгоритмов, вместе с принципом "Разделяй и властвуй" и динамическим программированием.
 
Жадный алгоритм - это алгоритм, который на каждом шагу совершает локально оптимальные решения, т.е. максимально возможное из допустимых, не учитывая предыдущие или следующие шаги.
Последовательность этих локально оптимальных решений приводит (не всегда) к глобально оптимальному решению.
Т.е. задача рабивается на подзадачи, в каждой подзадаче делается оптимальное решение и, в итоге, вся задача решается оптимально. При этом важно является ли каждое локальное решение безопасным шагом. Безопасный шаг - приводящий к оптимальному решению.
К примеру, алгоритм Дейкстры нахождения кратчайшего пути в графе вполне себе жадный, потому что мы на каждом шагу ищем вершину с наименьшим весом, в которой мы еще не бывали, после чего обновляем значения других вершин. При этом можно доказать, что кратчайшие пути, найденные в вершинах, являются оптимальными.

Расскажите про пузырьковую сортировку.
Будем идти по массиву слева направо. Если текущий элемент больше следующего, меняем их местами. Делаем так, пока массив не будет отсортирован.
Aсимптотика в худшем и среднем случае – O(n^2), в лучшем случае – O(n) - массив уже отсортирован.

Расскажите про быструю сортировку.
Выберем некоторый опорный элемент(pivot). После этого перекинем все элементы, меньшие его, налево, а большие – направо. Для этого используются дополнительные переменные - значения слева и справа, которые сравниваются с pivot. Рекурсивно вызовемся от каждой из частей, где будет выбран новый pivot. В итоге получим отсортированный массив, так как каждый элемент меньше опорного стоял раньше каждого большего опорного. Асимптотика: O(n*log(n)) в среднем и лучшем случае. Наихудшая оценка O(n^2) достигается при неудачном выборе опорного элемента.

Расскажите про сортировку слиянием.
Основана на парадигме «разделяй и властвуй». Будем делись массив пополам, пока не получим множество массивов из одного элемента. После чего выполним процедуру слияния: поддерживаем два указателя, один на текущий элемент первой части, второй – на текущий элемент второй части. Из этих двух элементов выбираем минимальный, вставляем в ответ и сдвигаем указатель, соответствующий минимуму. Так сделаем слияния массивов из 1го элемента в массивы по 2 элемента, затем из 2х в 4 и т.д. Слияние работает за O(n), уровней всего log(n), поэтому асимптотика O(n*log(n)).

Расскажите про бинарное дерево.
Бинарное дерево - иерархическая структура данных, в которой каждый узел может иметь двух потомков. Как правило, первый называется родительским узлом, а наследники называются левым и правым нодами/узлами. Каждый узел в дереве задаёт поддерево, корнем которого он является. Оба поддерева — левое и правое — тоже являются бинарными деревьями. Ноды, которые не имеют потомков, называются листьями дерева. У всех узлов левого поддерева произвольного узла X значения ключей данных меньше, нежели значение ключа данных самого узла X. У всех узлов правого поддерева произвольного узла X значения ключей данных больше либо равны, нежели значение ключа данных самого узла X. Этим достигается упорядоченная структура данных, то есть всегда отсортированная.
Поиск в лучшем случае - O(log(n)), худшем - O(n) - при вырождении в связанный список.

Расскажите про красно-черное дерево.
Усовершенствованная версия бинарного дерева. Каждый узел в к/ч дереве имеет дополнительное поле - цвет. К/ч дерево отвечает следующим требованиям:
1)	Узел либо красный, либо черный.
2)	Корень - черный.
3)	Все листья - черные и не хранят данных.
4)	Оба потомка каждого красного узла - черные.
5)	Любой простой путь от узла-предка до листового узла-потомка содержит одинаковое число черных узлов. Если не одинаковое, то происходит переворот.
При добавлении постоянно увеличивающихся/уменьшающихся чисел в бинарное дерево, оно вырождается в связанный список и теряет свои преимущества. Тогда как к/ч дерево может потребовать до двух поворотов для поддержки сбалансированности, чтобы избежать вырождения.
 
При операциях удаления в бинарном дереве для удаляемого узла надо найти замену. К/ч дерево сделает тоже самое, но потребует до трёх поворотов для поддержки сбалансированности.
В этом и состоит преимущство.
Сложность поиска, вставки и удаления - O(log(n))

Расскажите про линейный и бинарный поиск.
Линейный поиск - сложность O(n), так как все элементы проверяются по очереди.
Бинарный поиск - O(log(n)). Массив должен быть отсортирован. Происходит поиск индекса в массиве, содержащего искомое значение.
1)	Берем значение из середины массива и сраваем с искомым. Индекс середины считается по формуле mid = (high
+ low) / 2
low - индекс начала левого подмассива, high - индекс конца правого подмассива.
2)	Если значение в середине больше искомого, то рассматриваем левый подмассив и high = middle - 1
3)	Если меньше, то правый и low = middle + 1
4)	Повторяем, пока mid не страновится равен искомому элементу или подмассив не станет пустым. public static int binarySearch(int[] a, int key) {
int low = 0;
int high = a.length - 1;

while (low <= high) { int mid = (low + high)/2;

if (key > a[mid]) { low = mid + 1;
} else if (key < a[mid]) { high = mid - 1;
} else return mid;
}
return -1;
}

Расскажите про очередь и стек.
Stack это область хранения данных, находящееся в общей оперативной памяти (RAM). Всякий раз, когда вызывается метод, в памяти стека создается новый блок-фрейм, который содержит локальные переменные метода и ссылки на другие объекты в методе. Как только метод заканчивает работу, блок также перестает использоваться, тем самым предоставляя доступ для следующего метода. Размер стековой памяти намного меньше объема памяти в куче. Стек в Java работает по схеме LIFO
Queue - это очередь, которая обычно (но необязательно) строится по принципу FIFO (First-In-First-Out) - соответственно извлечение элемента осуществляется с начала очереди, вставка элемента - в конец очереди. Хотя этот принцип нарушает, к примеру PriorityQueue, использующая «natural ordering» или переданный Comparator при вставке нового элемента.
Deque (Double Ended Queue) расширяет Queue и согласно документации это линейная коллекция, поддерживающая вставку/извлечение элементов с обоих концов. Помимо этого реализации интерфейса Deque могут строится по принципу FIFO, либо LIFO.
Реализации и Deque, и Queue обычно не переопределяют методы equals() и hashCode(), вместо этого используются унаследованные методы класса Object, основанные на сравнении ссылок.
 
Сравните сложность вставки, удаления, поиска и доступа по индексу в ArrayList и LinkedList.
 
